<style>
@import url('https://fonts.googleapis.com/css2?family=Courier+Prime&display=swap');
.hermes-3000-widget * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

.hermes-3000-widget {
    font-family: 'Courier Prime', sans-serif;
    width: 100%;
    max-width: 900px;
    background-color: #ff6978;
    border-radius: 20px;
    box-shadow: 0 30px 60px rgba(0, 0, 0, 0.4), inset 0 -10px 30px rgba(0, 0, 0, 0.1);
    padding: 30px;
    position: relative;
}

.typewriter-base {
    background-color: #4a4a4a;
    border-radius: 15px;
    padding: 20px;
    display: flex;
    position: relative;
}

.left-panel {
    width: 80px;
    background-color: #6a6a6a;
    border-radius: 10px 0 0 10px;
    position: relative;
    margin-right: 20px;
}

.platen-knobs {
    position: absolute;
    top: 30px;
    left: 10px;
    right: 10px;
    display: flex;
    justify-content: space-between;
}

.platen-knob {
    width: 40px;
    height: 40px;
    background-color: #A5D6A7;
    border-radius: 50%;
    border: 4px solid #4a4a4a;
    cursor: pointer;
    transition: transform 0.1s;
}

.paper-area {
    flex-grow: 1;
    background-color: #f4efe0;
    border-radius: 5px;
    box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.1), 0 5px 15px rgba(0, 0, 0, 0.1);
    position: relative;
    overflow: hidden;
    height: 300px;
}

.paper-margin {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 40px;
    background: linear-gradient(to right, rgba(0, 0, 0, 0.05) 0px, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
    border-right: 1px solid rgba(0, 0, 0, 0.1);
}

#paper {
    height: 100%;
    padding: 20px;
    font-family: 'Courier Prime', monospace;
    font-size: 16px;
    line-height: 1.6;
    color: #2c3e50;
    background: linear-gradient(to right, transparent 40px, #d3d3d350 40px, transparent 41px), linear-gradient(#f5f5f500 0, #f5f5f500 1.2em, transparent 1.2em);
    background-size: 100% 1.2em;
    white-space: pre-wrap;
    word-wrap: break-word;
    overflow-y: auto;
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 10;
    outline: none;
}

#paper {
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    padding-bottom: 20px;
    min-height: 0;
}

.input-area {
    width: 100%;
    margin-top: 20px;
    display: flex;
    gap: 10px;
    height: 60px;
}

#text-input {
    flex-grow: 1;
    padding: 10px;
    border-radius: 5px;
    border: 1px solid #4a4a4a;
    height: 100%;
}

.start-typing-btn, .clear-paper-btn, .stop-typing-btn {
    background-color: #4a4a4a;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.2s;
    height: 100%;
    white-space: normal;
}

.start-typing-btn:hover, .clear-paper-btn:hover, .stop-typing-btn:hover {
    background-color: #6a6a6a;
}

.keyboard-container {
    display: flex;
    flex-direction: column;
    gap: 5px;
    margin-top: 20px;
    align-items: center;
    width: 100%;
}

.keyboard-row {
    display: flex;
    gap: 5px;
    justify-content: center;
    width: 100%;
}

.key {
    background-color: #6a6a6a;
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 5px;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 12px 16px;
    text-transform: uppercase;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.1s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 -2px 0 rgba(0, 0, 0, 0.1);
}

.key.wide {
    flex-grow: 1.5;
}

.key.tab {
    width: 60px;
}

.key.backspace {
    width: 80px;
}

.key.caps {
    width: 70px;
}

.key.enter {
    width: 90px;
}

.key.shift {
    width: 100px;
}

.key.space {
    width: 300px;
}

.key:hover {
    background-color: #8a8a8a;
}

.key.active, .key.typing {
    background-color: #A5D6A7;
    color: #4a4a4a;
    transform: translateY(2px);
    box-shadow: 0 0 4px rgba(0, 0, 0, 0.2), inset 0 2px 4px rgba(0, 0, 0, 0.2);
}

.carriage-return {
    position: absolute;
    right: 20px;
    top: 10px;
    width: 40px;
    height: 15px;
    background-color: #6a6a6a;
    transform: skew(-20deg);
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 -2px 0 rgba(0, 0, 0, 0.1);
}

.download-btn {
    display: block;
    width: 20%;
    background-color: #4a4a4a;
    color: white;
    border: none;
    padding: 10px;
    margin-top: 15px;
    cursor: pointer;
    border-radius: 5px;
    transition: background-color 0.2s;
}

.download-btn:hover {
    background-color: #6a6a6a;
}

#paper .cursor {
    animation: blink 0.7s infinite;
    border-right: 2px solid #2c3e50;
}

@keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
}

.text-transforms-controls {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-top: 15px;
    padding: 10px;
    background-color: #6a6a6a;
    border-radius: 5px;
}

.controls-row {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
}

.text-transforms-controls label {
    color: white;
    margin-right: 10px;
}

.text-transforms-controls select {
    padding: 5px;
    border-radius: 3px;
    margin-right: 10px;
}

.transform-btn {
    background-color: #A5D6A7;
    color: #4a4a4a;
    border: none;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.2s;
    margin-left: 5px;
}

.transform-btn:hover {
    background-color: #81c784;
}

.stop-typing-btn {
    background-color: #f44336;
}

.stop-typing-btn:hover {
    background-color: #e53935;
}
</style>

<div class="hermes-3000-widget">
    <div class="typewriter-base">
        <div class="left-panel">
            <div class="platen-knobs">
                <div class="platen-knob left-knob"></div>
                <div class="platen-knob right-knob"></div>
            </div>
        </div>
        <div class="paper-area">
            <div class="paper-margin"></div>
            <div id="paper" aria-label="Type your document"></div>
            <div class="carriage-return"></div>
        </div>
    </div>
    <div class="input-area">
        <button class="clear-paper-btn">AC</button>
        <textarea id="text-input" placeholder="Paste your text here..."></textarea>
        <button class="start-typing-btn">Start</button>
        <button class="stop-typing-btn">Stop</button>
    </div>
    <div class="text-transforms-controls">
        <div class="controls-row">
            <label for="transform-intensity">Intensity:</label>
            <select id="transform-intensity">
                <option value="little">A Little</option>
                <option value="some" selected>Some</option>
                <option value="many">Many</option>
                <option value="most">Most</option>
            </select>
            <button class="transform-btn" id="madlib-btn">↓Blanks</button>
            <button class="transform-btn" id="wordswap-btn">ΔOrder</button>
            <button class="transform-btn" id="phoneme-swap-btn">ΔVowels</button>
            <button class="transform-btn" id="consonant-swap-btn">ΔConsonants</button>
			<button class="transform-btn" id="lineSwap-btn">ΔLines</button>
        </div>
        <div class="controls-row">
            <button class="transform-btn" id="syllable-inversion-btn">↔Syllables</button>
            <button class="transform-btn" id="caesura-inversion-btn">↔Caesura</button>
            <button class="transform-btn" id="freak-btn">↓Freak</button>
            <button class="transform-btn" id="conjunction-swap-btn">ΔConjunctions</button>
            <button class="transform-btn" id="spoonerism-btn">↓Spoonerisms</button>
			<button class="transform-btn" id="numerologies-btn">ΔNumerologies</button>
        </div>
    </div>
    <div class="keyboard-container" id="keyboard">
        <div class="keyboard-row">
            <span class="key">q</span>
            <span class="key">w</span>
            <span class="key">e</span>
            <span class="key">r</span>
            <span class="key">t</span>
            <span class="key">y</span>
            <span class="key">u</span>
            <span class="key">i</span>
            <span class="key">o</span>
            <span class="key">p</span>
            <span class="key backspace">←</span>
        </div>
        <div class="keyboard-row">
            <span class="key tab">tab</span>
            <span class="key">a</span>
            <span class="key">s</span>
            <span class="key">d</span>
            <span class="key">f</span>
            <span class="key">g</span>
            <span class="key">h</span>
            <span class="key">j</span>
            <span class="key">k</span>
            <span class="key">l</span>
            <span class="key enter">↵</span>
        </div>
        <div class="keyboard-row">
            <span class="key shift">shift</span>
            <span class="key">z</span>
            <span class="key">x</span>
            <span class="key">c</span>
            <span class="key">v</span>
            <span class="key">b</span>
            <span class="key">n</span>
            <span class="key">m</span>
            <span class="key shift">shift</span>
        </div>
        <div class="keyboard-row">
            <span class="key space">space</span>
        </div>
    </div>
</div>
<button class="download-btn">Download Text File</button>

<script>
document.addEventListener('DOMContentLoaded', function () {
    initTypewriter();
});

// Try initialization immediately as well in case DOMContentLoaded already fired
if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(initTypewriter, 1);
}

function initTypewriter() {
    console.log("Initializing typewriter...");

    // Select all the necessary elements
    const widget = document.querySelector('.hermes-3000-widget');
    const paper = document.getElementById('paper');
    const keyboard = document.getElementById('keyboard');
    const keys = keyboard ? keyboard.querySelectorAll('.key') : [];
    const platenKnobs = document.querySelectorAll('.platen-knob');
    const carriageReturn = document.querySelector('.carriage-return');
    const downloadBtn = document.querySelector('.download-btn');
    const textInput = document.getElementById('text-input');
    const startTypingBtn = document.querySelector('.start-typing-btn');
    const clearPaperBtn = document.querySelector('.clear-paper-btn');
    const stopTypingBtn = document.querySelector('.stop-typing-btn');
    const transformIntensity = document.getElementById('transform-intensity');

    // Get the text transform controls container
    const textTransformsControls = document.querySelector('.text-transforms-controls');
    // Transformation buttons - using both ID and class selectors for better reliability
    let madlibBtn = document.getElementById('madlib-btn') || document.querySelector('.madlib-btn');
    let wordswapBtn = document.getElementById('wordswap-btn') || document.querySelector('.wordswap-btn');
    let phonemeSwapBtn = document.getElementById('phoneme-swap-btn') || document.querySelector('.phoneme-swap-btn');
    let consonantSwapBtn = document.getElementById('consonant-swap-btn') || document.querySelector('.consonant-swap-btn');
    let syllableInversionBtn = document.getElementById('syllable-inversion-btn') || document.querySelector('.syllable-inversion-btn');
    let caesuraInversionBtn = document.getElementById('caesura-inversion-btn') || document.querySelector('.caesura-inversion-btn');
    let lineSwapBtn = document.getElementById('lineSwap-btn') || document.querySelector('.lineSwap-btn');
    let prefixFreakBtn = document.getElementById('freak-btn') || document.querySelector('.freak-btn');
    let conjunctionSwapBtn = document.getElementById('conjunction-swap-btn') || document.querySelector('.conjunction-swap-btn');
    let spoonerismBtn = document.getElementById('spoonerism-btn') || document.querySelector('.spoonerism-btn');
    let numerologiesBtn = document.getElementById('numerologies-btn') || document.querySelector('.numerologies-btn');

    //  ---NEW---  Function to handle button creation and event listener attachment
    function setupTransformButton(button, transformFunction, transformName) {
        if (!button && textTransformsControls) {
            console.log(`Creating ${transformName} button...`);
            const newButton = document.createElement('button');
            newButton.textContent = transformName;
            newButton.id = `${transformName.toLowerCase().replace(' ', '-')}-btn`;
            newButton.classList.add('transform-btn');
            textTransformsControls.appendChild(newButton);
            button = newButton;  // Update the button variable
        }

        if (button) {
            console.log(`${transformName} button exists:`, button);
            button.addEventListener('click', () => processTextTransformation(transformFunction, transformName));
        } else {
            console.warn(`Could not find or create ${transformName} button`);
        }
        return button; // Return the button for consistency
    }

    // --- Create and/or attach listeners to all transform buttons ---
    madlibBtn = setupTransformButton(madlibBtn, createMadlib, "Madlib");
    wordswapBtn = setupTransformButton(wordswapBtn, shuffleLongWords, "Word Swap");
    phonemeSwapBtn = setupTransformButton(phonemeSwapBtn, enhancedPhonemeSwap, "Phoneme Swap");
    consonantSwapBtn = setupTransformButton(consonantSwapBtn, consonantSwap, "Consonant Swap");
    syllableInversionBtn = setupTransformButton(syllableInversionBtn, invertSyllables, "Syllable Inversion");
    caesuraInversionBtn = setupTransformButton(caesuraInversionBtn, invertAtCaesura, "Caesura Inversion");
    lineSwapBtn = setupTransformButton(lineSwapBtn, reorderPoemLines, "Line Swap");
    prefixFreakBtn = setupTransformButton(prefixFreakBtn, prefixFreak, "Prefix Freak");
    conjunctionSwapBtn = setupTransformButton(conjunctionSwapBtn, simpleConjunctionSwap, "Conjunction Swap");
    spoonerismBtn = setupTransformButton(spoonerismBtn, spoonerism, "Spoonerism");
    numerologiesBtn = setupTransformButton(numerologiesBtn, numerologiesTransform, "Numerologies");

    // Log elements to verify they're found
    console.log("Element checks:", {
        paper: !!paper,
        keyboard: !!keyboard,
        textInput: !!textInput,
        startTypingBtn: !!startTypingBtn,
        transformIntensity: !!transformIntensity,
        madlibBtn: !!madlibBtn,
        wordswapBtn: !!wordswapBtn,
        phonemeSwapBtn: !!phonemeSwapBtn,
        consonantSwapBtn: !!consonantSwapBtn,
        syllableInversionBtn: !!syllableInversionBtn,
        caesuraInversionBtn: !!caesuraInversionBtn,
        lineSwapBtn: !!lineSwapBtn,
        prefixFreakBtn: !!prefixFreakBtn,
        conjunctionSwapBtn: !!conjunctionSwapBtn,
        spoonerismBtn: !!spoonerismBtn,
        numerologiesBtn: !!numerologiesBtn
    });

    // Stop initialization if critical elements are missing
    if (!paper || !textInput) {
        console.error("Critical elements missing, cannot initialize typewriter");
        return;
    }

    // State variables
    let typingInProgress = false;
    let stopTyping = false;
    let paperContent = '';
    let processingTask = null;
    let processingElement = document.createElement('div');
    processingElement.className = 'processing-indicator';
    processingElement.textContent = 'Processing...';
    processingElement.style.display = 'none';
    if (widget) widget.appendChild(processingElement);

    // Make sure paper content starts at the bottom
    if (paper) {
        paper.style.display = "flex";
        paper.style.flexDirection = "column";
        paper.style.justifyContent = "flex-end";
    }

    // Unified implementation of getIntensityValue
    function getIntensityValue(totalItems, intensity) {
        const intensityMap = {
            'little': Math.max(1, Math.floor(totalItems * 0.05)),
            'some': Math.max(1, Math.floor(totalItems * 0.25)),
            'many': Math.max(1, Math.floor(totalItems * 0.5)),
            'most': Math.max(1, Math.floor(totalItems * 0.75)),
            // Add support for other intensity names used elsewhere
            'minimal': Math.max(1, Math.floor(totalItems * 0.1)),
            'medium': Math.max(1, Math.floor(totalItems * 0.5)),
            'high': Math.max(1, Math.floor(totalItems * 0.75)),
            'max': totalItems
        };
        return intensityMap[intensity] || Math.max(1, Math.floor(totalItems * 0.25));
    }

    // Helper function to show/hide processing status
    function setProcessingStatus(isProcessing) {
        if (processingElement) {
            processingElement.style.display = isProcessing ? 'block' : 'none';
        }
    }

    // Helper function to display errors
    function displayError(message) {
        console.error(message);
        alert(message);
    }

    // Helper function to update text
    function updateText(text) {
        if (textInput) {
            textInput.value = text;
        }
    }

    // Helper function to preserve case when replacing words
    function preserveCase(original, replacement) {
        if (original === original.toUpperCase()) {
            return replacement.toUpperCase();
        } else if (original[0] === original[0].toUpperCase()) {
            return replacement.charAt(0).toUpperCase() + replacement.slice(1).toLowerCase();
        }
        return replacement.toLowerCase();
    }

    // Improved madlib with optimization
    function createMadlib(text, intensity, progressCallback, completeCallback) {
        console.log("Creating madlib with intensity:", intensity);
        // Break down into a series of chunked operations
        const words = text.split(/\s+/);
        const madlibWords = [...words];
        const eligibleWords = words.filter(word => word.length >= 3);
        const wordsToReplace = getIntensityValue(eligibleWords.length, intensity);
        const usedIndexes = new Set();

        // Chunk the work in batches
        const chunkSize = 100;
        // Process 100 words at a time
        let replacedCount = 0;
        let currentIndex = 0;

        function processNextChunk() {
            const startTime = performance.now();
            // Process until chunk is complete or time limit exceeded
            while (replacedCount < wordsToReplace &&
                currentIndex < words.length &&
                performance.now() - startTime < 50) {

                const randomIndex = Math.floor(Math.random() * words.length);
                if (!usedIndexes.has(randomIndex) && words[randomIndex].length >= 3) {
                    madlibWords[randomIndex] = '[___]';
                    usedIndexes.add(randomIndex);
                    replacedCount++;
                }
                currentIndex++;
            }

            // Report progress
            if (progressCallback) {
                const progress = Math.min(1, replacedCount / wordsToReplace);
                progressCallback(progress);
            }

            // Check if we're done
            if (replacedCount >= wordsToReplace || currentIndex >= words.length) {
                completeCallback(madlibWords.join(' '));
            } else {
                // Schedule the next chunk
                setTimeout(processNextChunk, 0);
            }
        }

        // Start the first chunk
        setTimeout(processNextChunk, 0);
    }

    // Word shuffling with chunking for performance
    function shuffleLongWords(text, intensity, progressCallback, completeCallback) {
        console.log("Shuffling words with intensity:", intensity);
        const words = text.split(/\s+/);
        const longWordIndices = words.reduce((indices, word, index) => {
            if (word.length >= 5) indices.push(index);
            return indices;
        }, []);
        const swapsNeeded = getIntensityValue(Math.floor(longWordIndices.length / 2), intensity);
        const swappedIndices = new Set();
        let swapsPerformed = 0;
        // Process in chunks to avoid UI freezing
        function processChunk() {
            const startTime = performance.now();
            while (swapsPerformed < swapsNeeded &&
                longWordIndices.length >= 2 &&
                performance.now() - startTime < 50) {

                const idx1 = Math.floor(Math.random() * longWordIndices.length);
                let idx2 = Math.floor(Math.random() * longWordIndices.length);

                while (idx1 === idx2) {
                    idx2 = Math.floor(Math.random() * longWordIndices.length);
                }

                const wordIdx1 = longWordIndices[idx1];
                const wordIdx2 = longWordIndices[idx2];

                if (!swappedIndices.has(wordIdx1) && !swappedIndices.has(wordIdx2)) {
                    [words[wordIdx1], words[wordIdx2]] = [words[wordIdx2], words[wordIdx1]];
                    swappedIndices.add(wordIdx1);
                    swappedIndices.add(wordIdx2);
                    swapsPerformed++;
                }
            }

            // Report progress
            if (progressCallback) {
                const progress = Math.min(1, swapsPerformed / swapsNeeded);
                progressCallback(progress);
            }

            // Check if we're done
            if (swapsPerformed >= swapsNeeded || longWordIndices.length < 2) {
                completeCallback(words.join(' '));
            } else {
                // Schedule the next chunk
                setTimeout(processChunk, 0);
            }
        }

        // Start processing
        setTimeout(processChunk, 0);
    }

    // Improved phoneme swap with chunking
    function enhancedPhonemeSwap(text, intensity, progressCallback, completeCallback) {
        console.log("Swapping phonemes with intensity:", intensity);
        const vowels = 'aeiouAEIOU';
        const vowelMap = {
            'a': ['e', 'o'],
            'e': ['i', 'a'],
            'i': ['e', 'y'],
            'o': ['a', 'u'],
            'u': ['o', 'oo'],
            'A': ['E', 'O'],
            'E': ['I', 'A'],
            'I': ['E', 'Y'],
            'O': ['A', 'U'],
            'U': ['O', 'OO']
        };
        const words = text.split(/\s+/);
        const wordsToTransform = getIntensityValue(words.length, intensity);
        const transformedIndices = new Set();
        let transformCount = 0;
        let currentIndex = 0;

        function processChunk() {
            const startTime = performance.now();
            // Process this chunk
            while (transformCount < wordsToTransform &&
                currentIndex < words.length &&
                performance.now() - startTime < 50) {

                const randomIndex = Math.floor(Math.random() * words.length);
                if (words[randomIndex].length < 4 || transformedIndices.has(randomIndex)) {
                    currentIndex++;
                    continue;
                }

                let word = words[randomIndex];
                let transformed = '';
                let vowelFound = false;

                for (let i = 0; i < word.length; i++) {
                    const char = word[i];
                    if (vowels.includes(char)) {
                        const options = vowelMap[char] || [char];
                        transformed += options[Math.floor(Math.random() * options.length)];
                        vowelFound = true;
                    } else {
                        transformed += char;
                    }
                }

                if (vowelFound) {
                    words[randomIndex] = transformed;
                    transformedIndices.add(randomIndex);
                    transformCount++;
                }

                currentIndex++;
            }

            // Report progress
            if (progressCallback) {
                const progress = Math.min(1, transformCount / wordsToTransform);
                progressCallback(progress);
            }

            // Check if we're done
            if (transformCount >= wordsToTransform || currentIndex >= words.length) {
                completeCallback(words.join(' '));
            } else {
                // Schedule the next chunk
                setTimeout(processChunk, 0);
            }
        }

        // Start processing
        setTimeout(processChunk, 0);
    }

    // Improved consonant swap with chunking
    function consonantSwap(text, intensity, progressCallback, completeCallback) {
        console.log("Swapping consonants with intensity:", intensity);
        // Consonant pairs that won't lead to unreadable text
        const consonantPairs = {
            'b': 'p',
            'p': 'b',
            'd': 't',
            't': 'd',
            'g': 'k',
            'k': 'g',
            'v': 'f',
            'f': 'v',
            'z': 's',
            's': 'z',
            'j': 'ch',
            'c': 'k',
            'B': 'P',
            'P': 'B',
            'D': 'T',
            'T': 'D',
            'G': 'K',
            'K': 'G',
            'V': 'F',
            'F': 'V',
            'Z': 'S',
            'S': 'Z',
            'J': 'Ch',
            'C': 'K'
        };

        const words = text.split(/\s+/);
        const intensityValue = parseFloat(intensity === 'little' ? 0.1 :
            intensity === 'some' ? 0.2 :
            intensity === 'many' ? 0.4 :
            0.6);
        let processedCount = 0;
        const totalWords = words.length;
        const results = new Array(totalWords);
        // Use chunk processing to avoid UI freezing
        function processChunk(startIdx, endIdx) {
            const start = performance.now();
            for (let i = startIdx; i < endIdx && i < totalWords; i++) {
                const word = words[i];
                if (word.length < 4 || Math.random() > intensityValue) {
                    results[i] = word;
                    continue;
                }

                let result = '';
                for (let j = 0; j < word.length; j++) {
                    const char = word[j];
                    // Only swap some consonants to avoid making text unreadable
                    if (consonantPairs[char] && Math.random() < 0.5) {
                        result += consonantPairs[char];
                    } else {
                        result += char;
                    }
                }
                results[i] = result;
                // Check if we've been processing too long
                if (i % 10 === 0 && performance.now() - start > 50) {
                    processedCount = i + 1;
                    // Report progress
                    if (progressCallback) {
                        progressCallback(processedCount / totalWords);
                    }

                    // Schedule next chunk
                    setTimeout(() => processChunk(i + 1, endIdx), 0);
                    return;
                }
            }

            processedCount = endIdx;// Report progress
            if (progressCallback) {
                progressCallback(processedCount / totalWords);
            }

            if (processedCount >= totalWords) {
                completeCallback(results.join(' '));
            } else {
                // Process next chunk
                const nextEnd = Math.min(processedCount + 200, totalWords);
                setTimeout(() => processChunk(processedCount, nextEnd), 0);
            }
        }

        // Start processing in chunks of 200 words
        const firstChunkEnd = Math.min(200, totalWords);
        setTimeout(() => processChunk(0, firstChunkEnd), 0);
    }

    // Improved syllable inversion with chunking
    function invertSyllables(text, intensity, progressCallback, completeCallback) {
        console.log("Inverting syllables with intensity:", intensity);
        const words = text.split(/\s+/);
        const intensityValue = parseFloat(intensity === 'little' ? 0.1 :
            intensity === 'some' ? 0.25 :
            intensity === 'many' ? 0.5 :
            0.75);
        const totalWords = words.length;
        const results = new Array(totalWords);
        let processedCount = 0;

        function processChunk(startIdx, endIdx) {
            const start = performance.now();
            for (let i = startIdx; i < endIdx && i < totalWords; i++) {
                const word = words[i];
                if (word.length < 4 || Math.random() > intensityValue) {
                    results[i] = word;
                    continue;
                }

                // Simple approximation - reverse the word or swap halves
                if (Math.random() < 0.5) {
                    results[i] = word.split('').reverse().join('');
                } else {
                    const mid = Math.floor(word.length / 2);
                    results[i] = word.substring(mid) + word.substring(0, mid);
                }

                // Check if we've been processing too long
                if (i % 20 === 0 && performance.now() - start > 50) {
                    processedCount = i + 1;
                    // Report progress
                    if (progressCallback) {
                        progressCallback(processedCount / totalWords);
                    }

                    // Schedule next chunk
                    setTimeout(() => processChunk(i + 1, endIdx), 0);
                    return;
                }
            }

            processedCount = endIdx;
            // Report progress
            if (progressCallback) {
                progressCallback(processedCount / totalWords);
            }

            if (processedCount >= totalWords) {
                completeCallback(results.join(' '));
            } else {
                // Process next chunk
                const nextEnd = Math.min(processedCount + 200, totalWords);
                setTimeout(() => processChunk(processedCount, nextEnd), 0);
            }
        }

        // Start processing in chunks
        const firstChunkEnd = Math.min(200, totalWords);
        setTimeout(() => processChunk(0, firstChunkEnd), 0);
    }

    // Fixed caesura inversion with chunking
    function invertAtCaesura(text, intensity, progressCallback, completeCallback) {
        console.log("Inverting caesura with intensity:", intensity);
        // FIX: Split by newlines and preserve them in the result
        const lines = text.split('\n');
        const linesToTransform = getIntensityValue(lines.length, intensity);
        const transformedIndices = new Set();
        let transformCount = 0;
        let currentLineIndex = 0;
        const transformedLines = [...lines];

        function processChunk() {
            const startTime = performance.now();
            // Process lines in chunks
            while (transformCount < linesToTransform &&
                currentLineIndex < lines.length &&
                performance.now() - startTime < 50) {

                const randomIndex = Math.floor(Math.random() * lines.length);
                if (transformedIndices.has(randomIndex) || lines[randomIndex].trim().length < 10) {
                    currentLineIndex++;
                    continue;
                }

                const line = lines[randomIndex];
                // Find a natural division point
                let caesuraIndex = Math.floor(line.length / 2);
                // Check for punctuation first
                const punctuationMatch = line.match(/[;—,.]\s/);
                if (punctuationMatch) {
                    caesuraIndex = punctuationMatch.index + 1;
                } else {
                    // Or find nearest space to middle
                    const middleIndex = Math.floor(line.length / 2);
                    const beforeMiddle = line.lastIndexOf(' ', middleIndex);
                    const afterMiddle = line.indexOf(' ', middleIndex);
                    if (beforeMiddle !== -1 && afterMiddle !== -1) {
                        caesuraIndex = (middleIndex - beforeMiddle < afterMiddle - middleIndex) ?
                            beforeMiddle : afterMiddle;
                    } else if (beforeMiddle !== -1) {
                        caesuraIndex = beforeMiddle;
                    } else if (afterMiddle !== -1) {
                        caesuraIndex = afterMiddle;
                    } else {
                        caesuraIndex = middleIndex;
                    }
                }

                if (caesuraIndex > 0 && caesuraIndex < line.length - 1) {
                    const firstHalf = line.substring(0, caesuraIndex).trim();
                    const secondHalf = line.substring(caesuraIndex).trim();

                    transformedLines[randomIndex] = secondHalf + ' | ' + firstHalf;
                    transformedIndices.add(randomIndex);
                    transformCount++;
                }

                currentLineIndex++;
            }

            // Report progress
            if (progressCallback) {
                const progress = Math.min(1, transformCount / linesToTransform);
                progressCallback(progress);
            }

            // Check if we're done
            if (transformCount >= linesToTransform || currentLineIndex >= lines.length) {
                completeCallback(transformedLines.join('\n'));
            } else {
                // Schedule the next chunk
                setTimeout(processChunk, 0);
            }
        }

        // Start processing
        setTimeout(processChunk, 0);
    }

    // Fixed line reordering with chunking
    function reorderPoemLines(text, intensity, progressCallback, completeCallback) {
        console.log("Reordering poem lines with intensity:", intensity);
        // Split by newlines but preserve them
        const lines = text.split('\n');
        const nonEmptyLineIndices = [];
        // Find non-empty lines
        for (let i = 0; i < lines.length; i++) {
            if (lines[i].trim() !== '') {
                nonEmptyLineIndices.push(i);
            }
        }

        // Copy original lines
        const transformedLines = [...lines];
        // Determine how many pairs of lines to swap based on intensity
        const linesToReorder = Math.min(
            getIntensityValue(Math.floor(nonEmptyLineIndices.length / 2), intensity),
            Math.floor(nonEmptyLineIndices.length / 2)
        );
        // Track which indices we've already used
        const transformedIndices = new Set();
        let transformCount = 0;

        function processChunk() {
            const startTime = performance.now();
            // Process a chunk of swaps
            while (transformCount < linesToReorder &&
                nonEmptyLineIndices.length >= 2 &&
                performance.now() - startTime < 50) {

                // Get available indices (ones we haven't used yet)
                const availableIndices = nonEmptyLineIndices.filter(idx => !transformedIndices.has(idx));

                // If we don't have at least 2 available indices, break out
                if (availableIndices.length < 2) break;
                // Pick two random indices from available lines
                const randomIndex1 = Math.floor(Math.random() * availableIndices.length);
                let randomIndex2 = Math.floor(Math.random() * availableIndices.length);

                // Make sure we pick different indices
                while (randomIndex1 === randomIndex2) {
                    randomIndex2 = Math.floor(Math.random() * availableIndices.length);
                }

                // Get the actual line indices from the original array
                const lineIdx1 = availableIndices[randomIndex1];
                const lineIdx2 = availableIndices[randomIndex2];

                // Swap lines
                [transformedLines[lineIdx1], transformedLines[lineIdx2]] = 
                [transformedLines[lineIdx2], transformedLines[lineIdx1]];
                // Mark these indices as used
                transformedIndices.add(lineIdx1);
                transformedIndices.add(lineIdx2);
                transformCount++;
            }

            // Report progress
            if (progressCallback) {
                const progress = Math.min(1, transformCount / linesToReorder);
                progressCallback(progress);
            }

            // Check if we're done
            if (transformCount >= linesToReorder || nonEmptyLineIndices.length < 2) {
                completeCallback(transformedLines.join('\n'));
            } else {
                // Schedule the next chunk
                setTimeout(processChunk, 0);
            }
        }

        // Start processing
        setTimeout(processChunk, 0);
    }

    // Improved prefix freak with chunking
    function prefixFreak(text, intensity, progressCallback, completeCallback) {
        console.log("Prefix Freaking with intensity:", intensity);
        const prefixes = [
            "un", "in", "im", "il", "ir", "dis", "mono", "bi", "tri", "quad", "quart",
            "poly", "pre", "post", "re", "inter", "sub", "super", "sur", "hyper", "micro",
            "semi", "anti", "auto", "co", "ex", "mis", "non", "over", "pro", "trans",
            "under", "uni"
        ];
        const words = text.split(/\s+/);
        const freakAmount = getIntensityValue(words.length, intensity);
        let freakCount = 0;
        let processedWords = 0;
        const freaked = [...words];
        const usedIndexes = new Set();

        function processChunk() {
            const startTime = performance.now();
            while (freakCount < freakAmount &&
                processedWords < words.length &&
                performance.now() - startTime < 50) {

                const randomIndex = Math.floor(Math.random() * words.length);
                if (usedIndexes.has(randomIndex) || words[randomIndex].length < 4) {
                    processedWords++;
                    continue;
                }

                const word = words[randomIndex].toLowerCase();
                let matched = false;

                // Try each prefix
                for (let i = 0; i < prefixes.length; i++) {
                    const prefix = prefixes[i];
                    if (word.startsWith(prefix) && word.length > prefix.length + 2) {
                        // Split the word and insert "freaking"
                        freaked[randomIndex] = word.substring(0, prefix.length) +
                            "-freaking-" +
                            word.substring(prefix.length);
                        // Restore original case
                        if (words[randomIndex] !== word) {
                            // If first letter was uppercase, capitalize the result
                            if (words[randomIndex][0] === words[randomIndex][0].toUpperCase()) {
                                freaked[randomIndex] = freaked[randomIndex][0].toUpperCase() +
                                    freaked[randomIndex].substring(1);
                            }
                        }

                        freakCount++;
                        usedIndexes.add(randomIndex);
                        matched = true;
                        break;
                    }
                }

                processedWords++;
            }

            // Report progress
            if (progressCallback) {
                const progress = Math.min(1, freakCount / freakAmount);
                progressCallback(progress);
            }

            // Check if we're done
            if (freakCount >= freakAmount || processedWords >= words.length) {
                completeCallback(freaked.join(' '));
            } else {
                // Schedule the next chunk
                setTimeout(processChunk, 0);
            }
        }

        // Start processing
        setTimeout(processChunk, 0);
    }

    // Simple lists for the two main conjunction categories
    const coordinatingConjunctions = new Set(["and", "but", "or", "nor", "for", "yet", "so"]);
    const subordinatingConjunctions = new Set([
        "although", "because", "if", "since", "though", "unless", "until",
        "when", "where", "while", "after", "before", "as", "whereas", "whether"
    ]);
    // Helper function to shuffle array
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    // Fixed conjunction swap with chunking
    function simpleConjunctionSwap(text, intensity, progressCallback, completeCallback) {
    console.log("Swapping conjunctions with intensity:", intensity);
    // Convert to arrays for random selection
    const coordArray = Array.from(coordinatingConjunctions);
    const suborArray = Array.from(subordinatingConjunctions);
    
    // Shuffle both arrays to get random replacements
    const shuffledCoord = shuffleArray([...coordArray]);
    const shuffledSubor = shuffleArray([...suborArray]);
    
    // Create maps for replacements
    const coordMap = {};
    const suborMap = {};
    
    // Populate maps with random replacements
    coordArray.forEach((conj, i) => {
        coordMap[conj] = shuffledCoord[i];
    });
    
    suborArray.forEach((conj, i) => {
        suborMap[conj] = shuffledSubor[i];
    });
    
    // Split text into words
    const words = text.split(/\s+/);
    const totalWords = words.length;
    let processedCount = 0;
    let swapCount = 0;
    
    // Calculate number of conjunctions to replace based on intensity
    const conjunctionsToReplace = getIntensityValue(
        totalWords * 0.1, // Estimate: conjunctions are ~10% of text
        intensity
    );
    
    // Create an array for the result
    const result = [...words];
    
    function processChunk(startIdx, endIdx) {
        const start = performance.now();
        
        for (let i = startIdx; i < endIdx && i < totalWords; i++) {
            const word = words[i].toLowerCase().replace(/[.,;!?]$/, '');
            
            if (coordinatingConjunctions.has(word)) {
                result[i] = preserveCase(words[i], coordMap[word]);
                swapCount++;
            } else if (subordinatingConjunctions.has(word)) {
                result[i] = preserveCase(words[i], suborMap[word]);
                swapCount++;
            }
            
            // Check if we've been processing too long
            if (i % 20 === 0 && performance.now() - start > 50) {
                processedCount = i + 1;
                
                // Report progress
                if (progressCallback) {
                    progressCallback(Math.min(1, swapCount / conjunctionsToReplace));
                }
                
                // Schedule next chunk
                setTimeout(() => processChunk(processedCount, endIdx), 0);
                return;
            }
        }
        
        processedCount = endIdx;
        
        // Report progress
        if (progressCallback) {
            progressCallback(Math.min(1, swapCount / conjunctionsToReplace));
        }
        
        if (processedCount >= totalWords || swapCount >= conjunctionsToReplace) {
            completeCallback(result.join(' '));
        } else {
            // Process next chunk
            const nextEnd = Math.min(processedCount + 200, totalWords);
            setTimeout(() => processChunk(processedCount, nextEnd), 0);
        }
    }
    
    // Start processing in chunks
    const firstChunkEnd = Math.min(200, totalWords);
    setTimeout(() => processChunk(0, firstChunkEnd), 0);
}

// Spoonerism function with chunking
function spoonerism(text, intensity, progressCallback, completeCallback) {
    console.log("Creating spoonerisms with intensity:", intensity);
    
    // Split into sentences
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
    const sentencesToModify = getIntensityValue(sentences.length, intensity);
    let modifiedCount = 0;
    let processedCount = 0;
    const results = [];
    
    function processChunk() {
        const startTime = performance.now();
        
        while (modifiedCount < sentencesToModify && 
               processedCount < sentences.length &&
               performance.now() - startTime < 50) {
            
            const sentence = sentences[processedCount];
            const words = sentence.trim().split(/\s+/);
            
            if (words.length >= 2) {
                // Find two consecutive words that both start with consonants
                for (let i = 0; i < words.length - 1; i++) {
                    if (modifiedCount >= sentencesToModify) break;
                    
                    const word1 = words[i];
                    const word2 = words[i + 1];
                    
                    // Skip short words
                    if (word1.length < 2 || word2.length < 2) continue;
                    
                    // Find first consonant clusters
                    const consonantMatch1 = word1.match(/^([^aeiou]+)/i);
                    const consonantMatch2 = word2.match(/^([^aeiou]+)/i);
                    
                    if (consonantMatch1 && consonantMatch2) {
                        const consonant1 = consonantMatch1[0];
                        const consonant2 = consonantMatch2[0];
                        
                        // Swap the consonant clusters
                        words[i] = consonant2 + word1.substring(consonant1.length);
                        words[i + 1] = consonant1 + word2.substring(consonant2.length);
                        
                        modifiedCount++;
                        break;
                    }
                }
            }
            
            results.push(words.join(' '));
            processedCount++;
        }
        
        // Report progress
        if (progressCallback) {
            const progress = Math.min(1, modifiedCount / sentencesToModify);
            progressCallback(progress);
        }
        
        // Check if we're done
        if (modifiedCount >= sentencesToModify || processedCount >= sentences.length) {
            // Add appropriate punctuation back
            const finalResult = results.join('. ') + '.';
            completeCallback(finalResult);
        } else {
            // Schedule the next chunk
            setTimeout(processChunk, 0);
        }
    }
    
    // Start processing
    setTimeout(processChunk, 0);
}


    // Numerologies function with chunking
    function numerologiesTransform(text, intensity, progressCallback, completeCallback) {
        console.log("Applying numerologies with intensity:", intensity);
        const words = text.split(/\s+/);
        const transformedWords = [...words];
        const wordsToTransform = getIntensityValue(words.length, intensity);
        const transformedIndices = new Set();
        let transformCount = 0;
        let currentIndex = 0;

        function processChunk() {
            const startTime = performance.now();
            while (transformCount < wordsToTransform &&
                currentIndex < words.length &&
                performance.now() - startTime < 50) {

                const randomIndex = Math.floor(Math.random() * words.length);
                if (transformedIndices.has(randomIndex) || words[randomIndex].length < 3) {
                    currentIndex++;
                    continue;
                }

                const word = words[randomIndex];
                let transformed = '';
                for (let i = 0; i < word.length; i++) {
                    const charCode = word.charCodeAt(i);
                    // Basic numerology: A=1, B=2, etc.
                    if ((charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122)) {
                        const base = charCode >= 97 ? 97 : 65;
                        transformed += (charCode - base + 1) + ' ';
                    } else {
                        transformed += word[i];
                    }
                }

                transformedWords[randomIndex] = transformed.trim();
                transformedIndices.add(randomIndex);
                transformCount++;
                currentIndex++;
            }

            // Report progress
            if (progressCallback) {
                const progress = Math.min(1, transformCount / wordsToTransform);
                progressCallback(progress);
            }

            // Check if we're done
            if (transformCount >= wordsToTransform || currentIndex >= words.length) {
                completeCallback(transformedWords.join(' '));
            } else {
                // Schedule the next chunk
                setTimeout(processChunk, 0);
            }
        }

        // Start processing
        setTimeout(processChunk, 0);
    }

    // Centralized text processing function
    function processTextTransformation(transformFunction, transformName) {
    if (typingInProgress) {
        console.warn("Cannot transform text while typing is in progress");
        return;
    }
    
    const intensity = transformIntensity ? transformIntensity.value : 'some';
    const inputText = textInput.value;
    
    if (!inputText.trim()) {
        console.warn("No text to transform");
        return;
    }
    
    console.log(`Starting ${transformName} transformation with intensity: ${intensity}`);
    setProcessingStatus(true);
    
    if (processingTask) {
        clearTimeout(processingTask);
    }
    
    processingTask = setTimeout(() => {
        transformFunction(
            inputText,
            intensity,
            (progress) => {
                console.log(`${transformName} progress: ${Math.round(progress * 100)}%`);
            },
            (transformedText) => {
                updateText(transformedText);
                setProcessingStatus(false);
                console.log(`${transformName} transformation complete`);
            }
        );
    }, 10);
}

// Helper function to animate key press
function animateKeyPress(key) {
    if (!key) return;
    
    key.classList.add('pressed');
    setTimeout(() => {
        key.classList.remove('pressed');
    }, 100);
}

// Helper function to simulate typing
function simulateTyping(text, index, onComplete) {
    if (stopTyping) {
        stopTyping = false;
        typingInProgress = false;
        if (onComplete) onComplete();
        return;
    }
    
    if (index < text.length) {
        const char = text.charAt(index);
        
        // Skip non-printable characters
        if (char.charCodeAt(0) < 32) {
            setTimeout(() => simulateTyping(text, index + 1, onComplete), 10);
            return;
        }
        
        // Type the character
        paperContent += char;
        if (paper) {
            // Create a new span for the character
            const charSpan = document.createElement('span');
            charSpan.textContent = char;
            charSpan.className = 'typed-char';
            paper.appendChild(charSpan);
            
            // Scroll to bottom to see new content
            paper.scrollTop = paper.scrollHeight;
        }
        
        // Find and animate the key if possible
        if (keys && keys.length > 0) {
            let keyToPress = null;
            // Try to find the key by data-key attribute
            for (const key of keys) {
                if (key.getAttribute('data-key') === char.toLowerCase()) {
                    keyToPress = key;
                    break;
                }
            }
            
            // If not found, try to find by text content
            if (!keyToPress) {
                for (const key of keys) {
                    if (key.textContent.toLowerCase() === char.toLowerCase()) {
                        keyToPress = key;
                        break;
                    }
                }
            }
            
            // Animate the key press
            if (keyToPress) {
                animateKeyPress(keyToPress);
            } else if (char === ' ') {
                // Animate space bar if character is space
                const spaceBar = document.querySelector('.space-bar');
                if (spaceBar) animateKeyPress(spaceBar);
            }
        }
        
        // Type the next character after a delay
        const typingSpeed = Math.random() * 100 + 50; // Random delay between 50-150ms
        setTimeout(() => simulateTyping(text, index + 1, onComplete), typingSpeed);
    } else {
        // Typing complete
        typingInProgress = false;
        if (onComplete) onComplete();
    }
}

// Event listeners for buttons
if (startTypingBtn) {
    startTypingBtn.addEventListener('click', function() {
        if (typingInProgress) {
            console.warn("Typing already in progress");
            return;
        }
        
        const text = textInput.value;
        if (!text.trim()) {
            displayError("Please enter text to type!");
            return;
        }
        
        typingInProgress = true;
        simulateTyping(text, 0, () => {
            console.log("Typing complete");
        });
    });
}

if (stopTypingBtn) {
    stopTypingBtn.addEventListener('click', function() {
        if (typingInProgress) {
            stopTyping = true;
            console.log("Typing stopped");
        }
    });
}

if (clearPaperBtn) {
    clearPaperBtn.addEventListener('click', function() {
        if (typingInProgress) {
            displayError("Cannot clear paper while typing is in progress");
            return;
        }
        
        paperContent = '';
        if (paper) {
            paper.innerHTML = '';
        }
        console.log("Paper cleared");
    });
}

if (downloadBtn) {
    downloadBtn.addEventListener('click', function() {
        if (!paperContent.trim()) {
            displayError("No content to download");
            return;
        }
        
        // Create a blob and download it
        const blob = new Blob([paperContent], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'typewriter-output.txt';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        console.log("Content downloaded");
    });
}

// Animate carriage return if available
if (carriageReturn) {
    carriageReturn.addEventListener('click', function() {
        if (typingInProgress) return;
        
        carriageReturn.classList.add('pressed');
        setTimeout(() => {
            carriageReturn.classList.remove('pressed');
            
            // Add a new line to the paper
            paperContent += '\n';
            if (paper) {
                paper.appendChild(document.createElement('br'));
                paper.scrollTop = paper.scrollHeight;
            }
        }, 100);
    });
}

// Animate platen knobs if available
if (platenKnobs.length > 0) {
    platenKnobs.forEach(knob => {
        knob.addEventListener('click', function() {
            if (typingInProgress) return;
            
            knob.classList.add('rotating');
            setTimeout(() => {
                knob.classList.remove('rotating');
                
                // Add a new line to the paper
                paperContent += '\n';
                if (paper) {
                    paper.appendChild(document.createElement('br'));
                    paper.scrollTop = paper.scrollHeight;
                }
            }, 500);
        });
    });
}

console.log("Typewriter initialization complete");
}
</script>
