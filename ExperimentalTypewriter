<style>
@import url('https://fonts.googleapis.com/css2?family=Courier+Prime&display=swap');
.hermes-3000-widget * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

.hermes-3000-widget {
    font-family: 'Courier Prime', sans-serif;
    width: 100%;
    max-width: 900px;
    background-color: #ff6978;
    border-radius: 20px;
    box-shadow: 0 30px 60px rgba(0, 0, 0, 0.4), inset 0 -10px 30px rgba(0, 0, 0, 0.1);
    padding: 30px;
    position: relative;
}

.typewriter-base {
    background-color: #4a4a4a;
    border-radius: 15px;
    padding: 20px;
    display: flex;
    position: relative;
}

.left-panel {
    width: 80px;
    background-color: #6a6a6a;
    border-radius: 10px 0 0 10px;
    position: relative;
    margin-right: 20px;
}

.platen-knobs {
    position: absolute;
    top: 30px;
    left: 10px;
    right: 10px;
    display: flex;
    justify-content: space-between;
}

.platen-knob {
    width: 40px;
    height: 40px;
    background-color: #A5D6A7;
    border-radius: 50%;
    border: 4px solid #4a4a4a;
    cursor: pointer;
    transition: transform 0.1s;
}

.paper-area {
    flex-grow: 1;
    background-color: #f4efe0;
    border-radius: 5px;
    box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.1), 0 5px 15px rgba(0, 0, 0, 0.1);
    position: relative;
    overflow: hidden;
    height: 300px;
}

.paper-margin {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 40px;
    background: linear-gradient(to right, rgba(0, 0, 0, 0.05) 0px, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
    border-right: 1px solid rgba(0, 0, 0, 0.1);
}

#paper {
    height: 100%;
    padding: 20px;
    font-family: 'Courier Prime', monospace;
    font-size: 16px;
    line-height: 1.6;
    color: #2c3e50;
    background: linear-gradient(to right, transparent 40px, #d3d3d350 40px, transparent 41px), linear-gradient(#f5f5f500 0, #f5f5f500 1.2em, transparent 1.2em);
    background-size: 100% 1.2em;
    white-space: pre-wrap;
    word-wrap: break-word;
    overflow-y: auto;
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 10;
    outline: none;
}
/* Add these styles to your existing CSS */
#paper {
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    padding-bottom: 20px;
    min-height: 0; /* Helps with flex containers */
}

.input-area {
    width: 100%;
    margin-top: 20px;
    display: flex;
    gap: 10px;
    height: 60px;
}

#text-input {
    flex-grow: 1;
    padding: 10px;
    border-radius: 5px;
    border: 1px solid #4a4a4a;
    height: 100%;
}

.start-typing-btn, .clear-paper-btn {
    background-color: #4a4a4a;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.2s;
    height: 100%;
    white-space: normal;
}

.start-typing-btn:hover, .clear-paper-btn:hover {
    background-color: #6a6a6a;
}

.keyboard-container {
    display: flex;
    flex-direction: column;
    gap: 5px;
    margin-top: 20px;
    align-items: center;
    width: 100%;
}

.keyboard-row {
    display: flex;
    gap: 5px;
    justify-content: center;
    width: 100%;
}

.key {
    background-color: #6a6a6a;
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 5px;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 12px 16px;
    text-transform: uppercase;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.1s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 -2px 0 rgba(0, 0, 0, 0.1);
}

.key.wide {
    flex-grow: 1.5;
}

.key.tab {
    width: 60px;
}

.key.backspace {
    width: 80px;
}

.key.caps {
    width: 70px;
}

.key.enter {
    width: 90px;
}

.key.shift {
    width: 100px;
}

.key.space {
    width: 300px;
}

.key:hover {
    background-color: #8a8a8a;
}

.key.active, .key.typing {
    background-color: #A5D6A7;
    color: #4a4a4a;
    transform: translateY(2px);
    box-shadow: 0 0 4px rgba(0, 0, 0, 0.2), inset 0 2px 4px rgba(0, 0, 0, 0.2);
}

.carriage-return {
    position: absolute;
    right: 20px;
    top: 10px;
    width: 40px;
    height: 15px;
    background-color: #6a6a6a;
    transform: skew(-20deg);
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 -2px 0 rgba(0, 0, 0, 0.1);
}

.download-btn {
    display: block;
    width: 20%;
    background-color: #4a4a4a;
    color: white;
    border: none;
    padding: 10px;
    margin-top: 15px;
    cursor: pointer;
    border-radius: 5px;
    transition: background-color 0.2s;
}

.download-btn:hover {
    background-color: #6a6a6a;
}

#paper .cursor {
    animation: blink 0.7s infinite;
    border-right: 2px solid #2c3e50;
}

@keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
}

.text-transforms-controls {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 15px;
    padding: 10px;
    background-color: #6a6a6a;
    border-radius: 5px;
    height: 60px;
}

.text-transforms-controls label {
    color: white;
    margin-right: 10px;
}

.text-transforms-controls select {
    padding: 5px;
    border-radius: 3px;
    margin-right: 10px;
}

.transform-btn {
    background-color: #A5D6A7;
    color: #4a4a4a;
    border: none;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.2s;
    margin-left: 5px;
}

transform-btn:hover {
    background-color: #81c784;
}
</style>

<div class="hermes-3000-widget">
    <div class="typewriter-base">
        <div class="left-panel">
            <div class="platen-knobs">
                <div class="platen-knob left-knob"></div>
                <div class="platen-knob right-knob"></div>
            </div>
        </div>
        <div class="paper-area">
            <div class="paper-margin"></div>
            <div id="paper" aria-label="Type your document"></div>
            <div class="carriage-return"></div>
        </div>
    </div>
    <div class="input-area">
        <button class="clear-paper-btn">AC</button>
        <textarea id="text-input" placeholder="Paste your text here..."></textarea>
        <button class="start-typing-btn">Start Typing</button>
    </div>
    <div class="text-transforms-controls">
        <label for="transform-intensity">Intensity:</label>
        <select id="transform-intensity">
            <option value="little">A Little</option>
            <option value="some" selected>Some</option>
            <option value="many">Many</option>
            <option value="most">Most</option>
        </select>
        <button class="transform-btn" id="madlib-btn">→Blanks</button>
        <button class="transform-btn" id="wordswap-btn">ΔOrder</button>
        <button class="transform-btn" id="phoneme-swap-btn">ΔVowels</button>
        <button class="transform-btn" id="consonant-swap-btn">ΔConsonants</button>
        <button class="transform-btn" id="syllable-inversion-btn">ΔSyllables</button>
    </div>
    <div class="keyboard-container" id="keyboard">
        <div class="keyboard-row">
            <span class="key">q</span>
            <span class="key">w</span>
            <span class="key">e</span>
            <span class="key">r</span>
            <span class="key">t</span>
            <span class="key">y</span>
            <span class="key">u</span>
            <span class="key">i</span>
            <span class="key">o</span>
            <span class="key">p</span>
            <span class="key backspace">←</span>
        </div>
        <div class="keyboard-row">
            <span class="key tab">tab</span>
            <span class="key">a</span>
            <span class="key">s</span>
            <span class="key">d</span>
            <span class="key">f</span>
            <span class="key">g</span>
            <span class="key">h</span>
            <span class="key">j</span>
            <span class="key">k</span>
            <span class="key">l</span>
            <span class="key enter">↵</span>
        </div>
        <div class="keyboard-row">
            <span class="key shift">shift</span>
            <span class="key">z</span>
            <span class="key">x</span>
            <span class="key">c</span>
            <span class="key">v</span>
            <span class="key">b</span>
            <span class="key">n</span>
            <span class="key">m</span>
            <span class="key shift">shift</span>
        </div>
        <div class="keyboard-row">
            <span class="key space">space</span>
        </div>
    </div>
</div>
<button class="download-btn">Download Text File</button>

<script>
document.addEventListener('DOMContentLoaded', function() {
    (function() {
        const widget = document.querySelector('.hermes-3000-widget');
        const paper = widget.querySelector('#paper');
        const keyboard = widget.querySelector('#keyboard');
        const keys = keyboard.querySelectorAll('.key');
        const platenKnobs = widget.querySelectorAll('.platen-knob');
        const carriageReturn = widget.querySelector('.carriage-return');
        const downloadBtn = document.querySelector('.download-btn');
        const textInput = widget.querySelector('#text-input');
        const startTypingBtn = widget.querySelector('.start-typing-btn');
        const clearPaperBtn = widget.querySelector('.clear-paper-btn');
        const transformIntensity = document.querySelector('#transform-intensity');
        const madlibBtn = document.querySelector('#madlib-btn');
        const wordswapBtn = document.querySelector('#wordswap-btn');
        const phonemeSwapBtn = document.querySelector('#phoneme-swap-btn');
        const consonantSwapBtn = document.querySelector('#consonant-swap-btn');
        const syllableInversionBtn = document.querySelector('#syllable-inversion-btn');

        let typingInProgress = false;
        let stopTyping = false;
        let paperContent = '';

        // Add this CSS modification to position content at the bottom
        paper.style.display = "flex";
        paper.style.flexDirection = "column";
        paper.style.justifyContent = "flex-end";

        function getIntensityValue(totalItems, intensity) {
            const intensityMap = {
                'little': Math.floor(totalItems * 0.05),
                'some': Math.floor(totalItems * 0.25),
                'many': Math.floor(totalItems * 0.5),
                'most': Math.floor(totalItems * 0.75)
            };
            return intensityMap[intensity] || Math.floor(totalItems * 0.25);
        }

        function createMadlib(text, intensity) {
            const words = text.split(/\s+/);
            const madlibWords = [...words];

            const eligibleWords = words.filter(word => word.length >= 3);
            const wordsToReplace = getIntensityValue(eligibleWords.length, intensity);

            let replacedCount = 0;
            const usedIndexes = new Set();

            while (replacedCount < wordsToReplace && replacedCount < eligibleWords.length) {
                const randomIndex = Math.floor(Math.random() * words.length);

                if (usedIndexes.has(randomIndex) || words[randomIndex].length < 3) continue;

                madlibWords[randomIndex] = '[___]';
                usedIndexes.add(randomIndex);
                replacedCount++;
            }

            return madlibWords.join(' ');
        }

        function shuffleLongWords(text, intensity) {
            const words = text.split(/\s+/);
            const longWordIndices = [];

            for (let i = 0; i < words.length; i++) {
                if (words[i].length >= 5) {
                    longWordIndices.push(i);
                }
            }

            const swapsNeeded = getIntensityValue(Math.floor(longWordIndices.length / 2), intensity);
            const swappedIndices = new Set();
            let swapsPerformed = 0;

            while (swapsPerformed < swapsNeeded && longWordIndices.length >= 2) {
                const idx1 = Math.floor(Math.random() * longWordIndices.length);
                let idx2 = Math.floor(Math.random() * longWordIndices.length);

                while (idx1 === idx2) {
                    idx2 = Math.floor(Math.random() * longWordIndices.length);
                }

                const wordIdx1 = longWordIndices[idx1];
                const wordIdx2 = longWordIndices[idx2];

                if (swappedIndices.has(wordIdx1) || swappedIndices.has(wordIdx2)) {
                    continue;
                }

                [words[wordIdx1], words[wordIdx2]] = [words[wordIdx2], words[wordIdx1]];

                swappedIndices.add(wordIdx1);
                swappedIndices.add(wordIdx2);
                swapsPerformed++;
            }

            return words.join(' ');
        }

        function swapPhonemes(text, intensity) {
            const vowelMap = {
                'a': ['e', 'i', 'o', 'u'],
                'e': ['a', 'i', 'o', 'u'],
                'i': ['a', 'e', 'o', 'u'],
                'o': ['a', 'e', 'i', 'u'],
                'u': ['a', 'e', 'i', 'o']
            };

            function swapVowels(word) {
                let newWord = '';
                for (let char of word) {
                    if (vowelMap[char.toLowerCase()]) {
                        const replacements = vowelMap[char.toLowerCase()];
                        newWord += replacements[Math.floor(Math.random() * replacements.length)];
                    } else {
                        newWord += char;
                    }
                }
                return newWord;
            }

            const words = text.split(/\s+/);
            const wordsToSwap = getIntensityValue(words.length, intensity);
            const usedIndices = new Set();
            let swapsPerformed = 0;

            while (swapsPerformed < wordsToSwap && swapsPerformed < words.length) {
                const index = Math.floor(Math.random() * words.length);
                if (usedIndices.has(index) || words[index].length < 4) continue;

                words[index] = swapVowels(words[index]);
                usedIndices.add(index);
                swapsPerformed++;
            }
            
            return words.join(' ');
        }

        function consonantSwap(text, intensity) {
            // Voiced/Unvoiced consonant pairs (bidirectional mapping)
            const voicingPairs = {
                'b': 'p', 'p': 'b',
                'd': 't', 't': 'd',
                'g': 'k', 'k': 'g',
                'v': 'f', 'f': 'v',
                'z': 's', 's': 'z',
                'j': 'ch', 'ch': 'j', // Note: 'ch' will be handled specially as it's two characters
                'ð': 'θ', 'θ': 'ð'     // Representing voiced/unvoiced 'th' with IPA symbols
            };

            // Initial consonant blends - preserve category when swapping
            const initialBlends = [
                ['bl', 'br', 'cl', 'cr', 'dr', 'fl', 'fr', 'gl', 'gr'],
                ['pl', 'pr', 'sc', 'sk', 'sl', 'sm', 'sn', 'sp', 'st', 'sw', 'tr']
            ];

            // Final consonant blends - preserve category when swapping
            const finalBlends = [
                ['ct', 'ft', 'ld', 'lk', 'lp', 'lt'],
                ['mp', 'nd', 'nt', 'pt', 'rd', 'rk', 'rm', 'rn', 'rp', 'rt'],
                ['sk', 'sp', 'st']
            ];

            // Digraphs - treat as units
            const digraphs = ['sh', 'ch', 'ph', 'th', 'wh', 'ng'];

            // Helper function to check if a substring at position is a specific blend
            function isBlendAt(str, pos, blend) {
                return str.substring(pos, pos + blend.length).toLowerCase() === blend.toLowerCase();
            }

            // Helper function to find blend at position from a list of blend categories
            function findBlendAt(str, pos, blendCategories) {
                for (const category of blendCategories) {
                    for (const blend of category) {
                        if (isBlendAt(str, pos, blend)) {
                            // Return the blend and its category
                            return { blend, category };
                        }
                    }
                }
                return null;
            }

            // Helper function to swap a blend with another from the same category
            function swapBlend(blend, category) {
                // Filter out the current blend to avoid self-swapping
                const options = category.filter(b => b !== blend);
                
                if (options.length === 0) return blend;
                
                // Get a different blend from the same category
                return options[Math.floor(Math.random() * options.length)];
            }

            // Function to handle special cases like 'ch' -> 'j'
            function handleSpecialPairs(char, index, inputText) {
                if (char.toLowerCase() === 'c' && index < inputText.length - 1 && inputText[index + 1].toLowerCase() === 'h') {
                    return { replacement: voicingPairs['ch'], skipNext: true };
                }
                if (char.toLowerCase() === 'j') {
                    return { replacement: 'ch', skipNext: false };
                }
                // Handle 'th' sounds (both voiced and unvoiced)
                if (char.toLowerCase() === 't' && index < inputText.length - 1 && inputText[index + 1].toLowerCase() === 'h') {
                    // Approximating voiced/unvoiced 'th' distinction based on common words
                    const commonVoicedThWords = ['the', 'this', 'that', 'there', 'they', 'them', 'their', 'these', 'those', 'then'];
                    const context = inputText.substring(Math.max(0, index - 5), index + 7).toLowerCase();
                    const isLikelyVoiced = commonVoicedThWords.some(word => context.includes(word));
                    
                    return { 
                        replacement: isLikelyVoiced ? 'd' : 'f', // Simplified replacement for readable text
                        skipNext: true 
                    };
                }
                return null;
            }

            // Process the text word by word
            const words = text.split(/\s+/);
            const transformedWords = words.map(word => {
                if (word.length < 4) {
                    return word; // Skip words shorter than 4 letters
                }

                let result = '';
                for (let i = 0; i < word.length; i++) {
                    const char = word[i];
                    const isUpperCase = char === char.toUpperCase() && char !== char.toLowerCase();
                    const lowerChar = char.toLowerCase();
                    
                    // Check for special cases first
                    const specialCase = handleSpecialPairs(char, i, word);
                    if (specialCase) {
                        let replacement = specialCase.replacement;
                        if (isUpperCase && replacement.length > 0) {
                            replacement = replacement[0].toUpperCase() + replacement.substring(1);
                        }
                        result += replacement;
                        if (specialCase.skipNext) i++;
                        continue;
                    }
                    
                    // Check for initial blends at word boundaries or start
                    if (i === 0) {
                        const initialBlendInfo = findBlendAt(word, i, initialBlends);
                        if (initialBlendInfo) {
                            const newBlend = swapBlend(initialBlendInfo.blend, initialBlendInfo.category);
                            result += isUpperCase ? newBlend[0].toUpperCase() + newBlend.substring(1) : newBlend;
                            i += initialBlendInfo.blend.length - 1;
                            continue;
                        }
                    }
                    
                    // Check for final blends at word boundaries or end
                    if (i < word.length - 2 && i === word.length - 3) {
                        const finalBlendInfo = findBlendAt(word, i, finalBlends);
                        if (finalBlendInfo) {
                            const newBlend = swapBlend(finalBlendInfo.blend, finalBlendInfo.category);
                            result += isUpperCase ? newBlend[0].toUpperCase() + newBlend.substring(1) : newBlend;
                            i += finalBlendInfo.blend.length - 1;
                            continue;
                        }
                    }
                    
                    // Check for digraphs
                    let foundDigraph = false;
                    for (const digraph of digraphs) {
                        if (isBlendAt(word, i, digraph)) {
                            // For digraphs, apply the simple swap if first character is in a voicing pair
                            const firstChar = digraph[0].toLowerCase();
                            if (voicingPairs[firstChar]) {
                                const newDigraph = voicingPairs[firstChar] + digraph.substring(1);
                                result += isUpperCase ? newDigraph[0].toUpperCase() + newDigraph.substring(1) : newDigraph;
                            } else {
                                // If no swap for this digraph, keep it as is
                                result += word.substring(i, i + digraph.length);
                            }
                            i += digraph.length - 1;
                            foundDigraph = true;
                            break;
                        }
                    }
                    if (foundDigraph) continue;
                    
                    // Single consonant handling - apply voiced/unvoiced swap
                    if (voicingPairs[lowerChar]) {
                        let swapped = voicingPairs[lowerChar];
                        result += isUpperCase ? swapped.toUpperCase() : swapped;
                    } else {
                        // If not a consonant we're swapping, keep as is
                        result += char;
                    }
                }
                return result;
            });

            // Apply intensity
            const intensityMap = {
                'little': 0.25,
                'some': 0.5,
                'many': 0.75,
                'most': 1.0
            };
            const swapChance = intensityMap[intensity] || 0.5;

            const finalWords = transformedWords.map((word, index) => {
                if (words[index].length >= 4 && Math.random() < swapChance) {
                    return word;
                } else {
                    return words[index];
                }
            });

            return finalWords.join(' ');
        }

        function invertSyllables(text, intensity) {
            const words = text.split(/\s+/);
            const invertedWords = words.map(word => {
                if (word.length < 4) {
                    return word; // Skip words shorter than 4 letters
                }

                const syllables = [];
                let currentSyllable = '';
                const vowels = 'aeiouyAEIOUY';
                let lastCharWasVowel = false;

                for (let i = 0; i < word.length; i++) {
                    const char = word[i];
                    currentSyllable += char;

                    if (vowels.includes(char)) {
                        lastCharWasVowel = true;
                    } else {
                        if (lastCharWasVowel && i < word.length - 1 && !vowels.includes(word[i + 1])) {
                            syllables.push(currentSyllable);
                            currentSyllable = '';
                            lastCharWasVowel = false;
                        }
                    }
                }
                if (currentSyllable) {
                    syllables.push(currentSyllable);
                }

                const inverted = syllables.reverse().join('');

                // Apply intensity: invert only some words
                const intensityMap = {
                  'little': 0.25,
                  'some': 0.5,
                  'many': 0.75,
                  'most': 1.0
                };

                const inversionChance = intensityMap[intensity] || 0.5;

                if (Math.random() < inversionChance) {
                  return inverted;
                } else {
                  return word;
                }

            });
            return invertedWords.join(' ');
        }

        function activateKey(key) {
            const keyElement = keyboard.querySelector(`.key[data-key="${key}"]`) ||
                Array.from(keys).find(k => k.textContent.toLowerCase() === key);

            if (keyElement) {
                keyElement.classList.add('active');
                setTimeout(() => keyElement.classList.remove('active'), 100);
            }
        }

        document.addEventListener('keydown', function(event) {
            if (event.target === paper) {
                const key = event.key.toLowerCase();
                activateKey(key);
            }
        });

        keys.forEach(key => {
            key.addEventListener('mousedown', function(event) {
                event.preventDefault();
                const keyValue = this.textContent.toLowerCase();

                if (keyValue === '←') {
                    if (paperContent.length > 0) {
                        paperContent = paperContent.slice(0, -1);
                    }
                } else if (keyValue === '↵') {
                    paperContent += '\n';
                } else if (keyValue === 'space') {
                    paperContent += ' ';
                } else if (keyValue.length === 1) {
                    paperContent += keyValue;
                }

                this.classList.add('active');
                setTimeout(() => this.classList.remove('active'), 100);
                updatePaperContent();
            });
        });

        function clearPaper() {
            paperContent = '';
            updatePaperContent();
        }

        // New function to update paper content and ensure it stays at the bottom
        function updatePaperContent() {
            paper.innerHTML = paperContent + '<span class="cursor">|</span>';
            paper.scrollTop = paper.scrollHeight;
        }

        function animateKeyPress(key) {
            let keyToPress = key.toLowerCase();
            
            if (keyToPress === '\n') {
                keyToPress = '↵';
            } else if (keyToPress === ' ') {
                keyToPress = 'space';
            } else if (keyToPress === '\b') {
                keyToPress = '←';
            }
            
            const keyElement = Array.from(keys).find(k => k.textContent.toLowerCase() === keyToPress);

            if (keyElement) {
                keyElement.classList.add('typing');
                setTimeout(() => keyElement.classList.remove('typing'), 100);
            }
        }

        function typeText(text) {
            if (typingInProgress) {
                stopTyping = true;
                return;
            }
            
            typingInProgress = true;
            stopTyping = false;
            startTypingBtn.textContent = 'Stop';
            
            // Clear the paper before starting to type
            clearPaper();
            
            const lines = text.split('\n');
            let lineIndex = 0;
            let charIndex = 0;

            function typeLine() {
                if (stopTyping) {
                    typingInProgress = false;
                    startTypingBtn.textContent = 'Start Typing';
                    return;
                }
                
                if (lineIndex >= lines.length) {
                    typingInProgress = false;
                    startTypingBtn.textContent = 'Start Typing';
                    return;
                }

                const line = lines[lineIndex];
                
                if (charIndex < line.length) {
                    const char = line[charIndex];
                    animateKeyPress(char);
                    paperContent += char;
                    updatePaperContent();
                    charIndex++;
                    setTimeout(typeLine, 100);
                } else {
                    if (lineIndex < lines.length - 1) {
                        paperContent += '\n';
                        animateKeyPress('\n');
                        updatePaperContent();
                    }
                    
                    lineIndex++;
                    charIndex = 0;
                    setTimeout(typeLine, 300);
                }
            }
            
            typeLine();
        }

        function validateInput() {
            const text = textInput.value;
            if (!text.trim()) {
                alert('Please enter some text first');
                return false;
            }
            return true;
        }

        function applyTransformation(text) {
            // Only update the text input, don't update the paper
            textInput.value = text;
        }

        madlibBtn.addEventListener('click', () => {
            if (!validateInput()) return;
            applyTransformation(createMadlib(textInput.value, transformIntensity.value));
        });

        wordswapBtn.addEventListener('click', () => {
            if (!validateInput()) return;
            applyTransformation(shuffleLongWords(textInput.value, transformIntensity.value));
        });

        phonemeSwapBtn.addEventListener('click', () => {
            if (!validateInput()) return;
            applyTransformation(swapPhonemes(textInput.value, transformIntensity.value));
        });

        consonantSwapBtn.addEventListener('click', () => {
            if (!validateInput()) return;
            applyTransformation(consonantSwap(textInput.value, transformIntensity.value));
        });

        syllableInversionBtn.addEventListener('click', () => {
            if (!validateInput()) return;
            applyTransformation(invertSyllables(textInput.value, transformIntensity.value));
        });

        startTypingBtn.addEventListener('click', () => {
            if (typingInProgress) {
                stopTyping = true;
                startTypingBtn.textContent = 'Start Typing';
            } else {
                const text = textInput.value;
                if (text.trim()) {
                    typeText(text);
                } else {
                    alert('Please enter some text first');
                }
            }
        });

        clearPaperBtn.addEventListener('click', clearPaper);

        platenKnobs.forEach(knob => {
            knob.addEventListener('mousedown', function() {
                this.style.transform = 'scale(0.9)';
                setTimeout(() => {
                    this.style.transform = 'scale(1)';
                }, 100);
            });
        });

        carriageReturn.addEventListener('mousedown', function() {
            this.style.transform = 'skew(-20deg) translateY(3px)';
            setTimeout(() => {
                this.style.transform = 'skew(-20deg)';
            }, 100);
        });

        downloadBtn.addEventListener('click', function() {
            const text = paperContent;
            const blob = new Blob([text], { type: 'text/plain' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'typewriter_document.txt';
            link.click();
            URL.revokeObjectURL(link.href);
        });
    })();
});
</script>
