<style>
@import url('https://fonts.googleapis.com/css2?family=Courier+Prime&display=swap');
.hermes-3000-widget * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

.hermes-3000-widget {
    font-family: 'Courier Prime', sans-serif;
    width: 100%;
    max-width: 900px;
    background-color: #ff6978;
    border-radius: 20px;
    box-shadow: 0 30px 60px rgba(0, 0, 0, 0.4), inset 0 -10px 30px rgba(0, 0, 0, 0.1);
    padding: 30px;
    position: relative;
}

.typewriter-base {
    background-color: #4a4a4a;
    border-radius: 15px;
    padding: 20px;
    display: flex;
    position: relative;
}

.left-panel {
    width: 80px;
    background-color: #6a6a6a;
    border-radius: 10px 0 0 10px;
    position: relative;
    margin-right: 20px;
}

.platen-knobs {
    position: absolute;
    top: 30px;
    left: 10px;
    right: 10px;
    display: flex;
    justify-content: space-between;
}

.platen-knob {
    width: 40px;
    height: 40px;
    background-color: #A5D6A7;
    border-radius: 50%;
    border: 4px solid #4a4a4a;
    cursor: pointer;
    transition: transform 0.1s;
}

.paper-area {
    flex-grow: 1;
    background-color: #f4efe0;
    border-radius: 5px;
    box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.1), 0 5px 15px rgba(0, 0, 0, 0.1);
    position: relative;
    overflow: hidden;
    height: 300px;
}

.paper-margin {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 40px;
    background: linear-gradient(to right, rgba(0, 0, 0, 0.05) 0px, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
    border-right: 1px solid rgba(0, 0, 0, 0.1);
}

#paper {
    height: 100%;
    padding: 20px;
    font-family: 'Courier Prime', monospace;
    font-size: 16px;
    line-height: 1.6;
    color: #2c3e50;
    background: linear-gradient(to right, transparent 40px, #d3d3d350 40px, transparent 41px), linear-gradient(#f5f5f500 0, #f5f5f500 1.2em, transparent 1.2em);
    background-size: 100% 1.2em;
    white-space: pre-wrap;
    word-wrap: break-word;
    overflow-y: auto;
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 10;
    outline: none;
}

#paper {
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    padding-bottom: 20px;
    min-height: 0;
}

.input-area {
    width: 100%;
    margin-top: 20px;
    display: flex;
    gap: 10px;
    height: 60px;
}

#text-input {
    flex-grow: 1;
    padding: 10px;
    border-radius: 5px;
    border: 1px solid #4a4a4a;
    height: 100%;
}

.start-typing-btn, .clear-paper-btn, .stop-typing-btn {
    background-color: #4a4a4a;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.2s;
    height: 100%;
    white-space: normal;
}

.start-typing-btn:hover, .clear-paper-btn:hover, .stop-typing-btn:hover {
    background-color: #6a6a6a;
}

.keyboard-container {
    display: flex;
    flex-direction: column;
    gap: 5px;
    margin-top: 20px;
    align-items: center;
    width: 100%;
}

.keyboard-row {
    display: flex;
    gap: 5px;
    justify-content: center;
    width: 100%;
}

.key {
    background-color: #6a6a6a;
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 5px;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 12px 16px;
    text-transform: uppercase;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.1s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 -2px 0 rgba(0, 0, 0, 0.1);
}

.key.wide {
    flex-grow: 1.5;
}

.key.tab {
    width: 60px;
}

.key.backspace {
    width: 80px;
}

.key.caps {
    width: 70px;
}

.key.enter {
    width: 90px;
}

.key.shift {
    width: 100px;
}

.key.space {
    width: 300px;
}

.key:hover {
    background-color: #8a8a8a;
}

.key.active, .key.typing {
    background-color: #A5D6A7;
    color: #4a4a4a;
    transform: translateY(2px);
    box-shadow: 0 0 4px rgba(0, 0, 0, 0.2), inset 0 2px 4px rgba(0, 0, 0, 0.2);
}

.carriage-return {
    position: absolute;
    right: 20px;
    top: 10px;
    width: 40px;
    height: 15px;
    background-color: #6a6a6a;
    transform: skew(-20deg);
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 -2px 0 rgba(0, 0, 0, 0.1);
}

.download-btn {
    display: block;
    width: 20%;
    background-color: #4a4a4a;
    color: white;
    border: none;
    padding: 10px;
    margin-top: 15px;
    cursor: pointer;
    border-radius: 5px;
    transition: background-color 0.2s;
}

.download-btn:hover {
    background-color: #6a6a6a;
}

#paper .cursor {
    animation: blink 0.7s infinite;
    border-right: 2px solid #2c3e50;
}

@keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
}

.text-transforms-controls {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-top: 15px;
    padding: 10px;
    background-color: #6a6a6a;
    border-radius: 5px;
}

.controls-row {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
}

.text-transforms-controls label {
    color: white;
    margin-right: 10px;
}

.text-transforms-controls select {
    padding: 5px;
    border-radius: 3px;
    margin-right: 10px;
}

.transform-btn {
    background-color: #A5D6A7;
    color: #4a4a4a;
    border: none;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.2s;
    margin-left: 5px;
}

.transform-btn:hover {
    background-color: #81c784;
}

.stop-typing-btn {
    background-color: #f44336;
}

.stop-typing-btn:hover {
    background-color: #e53935;
}
</style>

<div class="hermes-3000-widget">
    <div class="typewriter-base">
        <div class="left-panel">
            <div class="platen-knobs">
                <div class="platen-knob left-knob"></div>
                <div class="platen-knob right-knob"></div>
            </div>
        </div>
        <div class="paper-area">
            <div class="paper-margin"></div>
            <div id="paper" aria-label="Type your document"></div>
            <div class="carriage-return"></div>
        </div>
    </div>
    <div class="input-area">
        <button class="clear-paper-btn">AC</button>
        <textarea id="text-input" placeholder="Paste your text here..."></textarea>
        <button class="start-typing-btn">Start</button>
        <button class="stop-typing-btn">Stop</button>
    </div>
    <div class="text-transforms-controls">
        <div class="controls-row">
            <label for="transform-intensity">Intensity:</label>
            <select id="transform-intensity">
                <option value="little">A Little</option>
                <option value="some" selected>Some</option>
                <option value="many">Many</option>
                <option value="most">Most</option>
            </select>
            <button class="transform-btn" id="madlib-btn">→Blanks</button>
            <button class="transform-btn" id="wordswap-btn">ΔOrder</button>
            <button class="transform-btn" id="phoneme-swap-btn">ΔVowels</button>
            <button class="transform-btn" id="consonant-swap-btn">ΔConsonants</button>
        </div>
        <div class="controls-row">
            <button class="transform-btn" id="syllable-inversion-btn">ΔSyllables</button>
            <button class="transform-btn" id="caesura-inversion-btn">↔Caesura</button>
            <button class="transform-btn" id="line-swap-btn">ΔLines</button>
            <button class="transform-btn" id="freak-btn">Freak</button>
            <button class="transform-btn" id="conjunction-swap-btn">ΔConjunctions</button>
        </div>
    </div>
    <div class="keyboard-container" id="keyboard">
        <div class="keyboard-row">
            <span class="key">q</span>
            <span class="key">w</span>
            <span class="key">e</span>
            <span class="key">r</span>
            <span class="key">t</span>
            <span class="key">y</span>
            <span class="key">u</span>
            <span class="key">i</span>
            <span class="key">o</span>
            <span class="key">p</span>
            <span class="key backspace">←</span>
        </div>
        <div class="keyboard-row">
            <span class="key tab">tab</span>
            <span class="key">a</span>
            <span class="key">s</span>
            <span class="key">d</span>
            <span class="key">f</span>
            <span class="key">g</span>
            <span class="key">h</span>
            <span class="key">j</span>
            <span class="key">k</span>
            <span class="key">l</span>
            <span class="key enter">↵</span>
        </div>
        <div class="keyboard-row">
            <span class="key shift">shift</span>
            <span class="key">z</span>
            <span class="key">x</span>
            <span class="key">c</span>
            <span class="key">v</span>
            <span class="key">b</span>
            <span class="key">n</span>
            <span class="key">m</span>
            <span class="key shift">shift</span>
        </div>
        <div class="keyboard-row">
            <span class="key space">space</span>
        </div>
    </div>
</div>
<button class="download-btn">Download Text File</button>

<script>

document.addEventListener('DOMContentLoaded', function () {
    initTypewriter();
});

// Try initialization immediately as well in case DOMContentLoaded already fired
if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(initTypewriter, 1);
}

function initTypewriter() {
    console.log("Initializing typewriter...");

    // Select all the necessary elements
    const widget = document.querySelector('.hermes-3000-widget');
    const paper = document.getElementById('paper');
    const keyboard = document.getElementById('keyboard');
    const keys = keyboard ? keyboard.querySelectorAll('.key') : [];
    const platenKnobs = document.querySelectorAll('.platen-knob');
    const carriageReturn = document.querySelector('.carriage-return');
    const downloadBtn = document.querySelector('.download-btn');
    const textInput = document.getElementById('text-input');
    const startTypingBtn = document.querySelector('.start-typing-btn');
    const clearPaperBtn = document.querySelector('.clear-paper-btn');
    const stopTypingBtn = document.querySelector('.stop-typing-btn');
    const transformIntensity = document.getElementById('transform-intensity');

    // Transformation buttons
    const madlibBtn = document.getElementById('madlib-btn');
    const wordswapBtn = document.getElementById('wordswap-btn');
    const phonemeSwapBtn = document.getElementById('phoneme-swap-btn');
    const consonantSwapBtn = document.getElementById('consonant-swap-btn');
    const syllableInversionBtn = document.getElementById('syllable-inversion-btn');
    const caesuraInversionBtn = document.getElementById('caesura-inversion-btn');
    const lineSwapBtn = document.getElementById('line-swap-btn');
    const prefixFreakBtn = document.getElementById('freak-btn');
    const conjunctionSwapBtn = document.getElementById('conjunction-swap-btn');

    // Log elements to verify they're found
    console.log("Element checks:", {
        paper: !!paper,
        keyboard: !!keyboard,
        textInput: !!textInput,
        startTypingBtn: !!startTypingBtn,
        madlibBtn: !!madlibBtn,
        wordswapBtn: !!wordswapBtn,
        phonemeSwapBtn: !!phonemeSwapBtn,
        consonantSwapBtn: !!consonantSwapBtn,
        syllableInversionBtn: !!syllableInversionBtn,
        caesuraInversionBtn: !!caesuraInversionBtn,
        lineSwapBtn: !!lineSwapBtn,
        prefixFreakBtn: !!prefixFreakBtn,
        conjunctionSwapBtn: !!conjunctionSwapBtn
    });

    // Stop initialization if critical elements are missing
    if (!paper || !textInput) {
        console.error("Critical elements missing, cannot initialize typewriter");
        return;
    }

    // State variables
    let typingInProgress = false;
    let stopTyping = false;
    let paperContent = '';
    let processingTask = null;
    let processingElement = document.createElement('div');
    processingElement.className = 'processing-indicator';
    processingElement.textContent = 'Processing...';
    processingElement.style.display = 'none';
    if (widget) widget.appendChild(processingElement);

    // Make sure paper content starts at the bottom
    if (paper) {
        paper.style.display = "flex";
        paper.style.flexDirection = "column";
        paper.style.justifyContent = "flex-end";
    }

    // Function to determine how many items to transform based on intensity
    function getIntensityValue(totalItems, intensity) {
        const intensityMap = {
            'little': Math.max(1, Math.floor(totalItems * 0.05)),
            'some': Math.max(1, Math.floor(totalItems * 0.25)),
            'many': Math.max(1, Math.floor(totalItems * 0.5)),
            'most': Math.max(1, Math.floor(totalItems * 0.75))
        };
        return intensityMap[intensity] || Math.max(1, Math.floor(totalItems * 0.25));
    }

    // Helper function to show/hide processing status
    function setProcessingStatus(isProcessing) {
        if (processingElement) {
            processingElement.style.display = isProcessing ? 'block' : 'none';
        }
    }

    // Helper function to display errors
    function displayError(message) {
        console.error(message);
        alert(message);
    }

    // Helper function to update text
    function updateText(text) {
        if (textInput) {
            textInput.value = text;
        }
    }

    // Helper function to preserve case when replacing words
    function preserveCase(original, replacement) {
        if (original === original.toUpperCase()) {
            return replacement.toUpperCase();
        } else if (original[0] === original[0].toUpperCase()) {
            return replacement.charAt(0).toUpperCase() + replacement.slice(1).toLowerCase();
        }
        return replacement.toLowerCase();
    }

    // Improved madlib with optimization
    function createMadlib(text, intensity, progressCallback, completeCallback) {
        console.log("Creating madlib with intensity:", intensity);
        
        // Break down into a series of chunked operations
        const words = text.split(/\s+/);
        const madlibWords = [...words];
        const eligibleWords = words.filter(word => word.length >= 3);
        const wordsToReplace = getIntensityValue(eligibleWords.length, intensity);
        const usedIndexes = new Set();
        
        // Chunk the work in batches
        const chunkSize = 100; // Process 100 words at a time
        let replacedCount = 0;
        let currentIndex = 0;
        
        function processNextChunk() {
            const startTime = performance.now();
            
            // Process until chunk is complete or time limit exceeded
            while (replacedCount < wordsToReplace && 
                   currentIndex < words.length && 
                   performance.now() - startTime < 50) { // 50ms time limit per chunk
                   
                const randomIndex = Math.floor(Math.random() * words.length);
                if (!usedIndexes.has(randomIndex) && words[randomIndex].length >= 3) {
                    madlibWords[randomIndex] = '[___]';
                    usedIndexes.add(randomIndex);
                    replacedCount++;
                }
                currentIndex++;
            }
            
            // Report progress
            if (progressCallback) {
                const progress = Math.min(1, replacedCount / wordsToReplace);
                progressCallback(progress);
            }
            
            // Check if we're done
            if (replacedCount >= wordsToReplace || currentIndex >= words.length) {
                completeCallback(madlibWords.join(' '));
            } else {
                // Schedule the next chunk
                setTimeout(processNextChunk, 0);
            }
        }
        
        // Start the first chunk
        setTimeout(processNextChunk, 0);
    }

    // Word shuffling with chunking for performance
    function shuffleLongWords(text, intensity, progressCallback, completeCallback) {
        console.log("Shuffling words with intensity:", intensity);
        
        const words = text.split(/\s+/);
        const longWordIndices = words.reduce((indices, word, index) => {
            if (word.length >= 5) indices.push(index);
            return indices;
        }, []);

        const swapsNeeded = getIntensityValue(Math.floor(longWordIndices.length / 2), intensity);
        const swappedIndices = new Set();
        let swapsPerformed = 0;
        
        // Process in chunks to avoid UI freezing
        function processChunk() {
            const startTime = performance.now();
            
            while (swapsPerformed < swapsNeeded && 
                   longWordIndices.length >= 2 &&
                   performance.now() - startTime < 50) {
                   
                const idx1 = Math.floor(Math.random() * longWordIndices.length);
                let idx2 = Math.floor(Math.random() * longWordIndices.length);

                while (idx1 === idx2) {
                    idx2 = Math.floor(Math.random() * longWordIndices.length);
                }

                const wordIdx1 = longWordIndices[idx1];
                const wordIdx2 = longWordIndices[idx2];

                if (!swappedIndices.has(wordIdx1) && !swappedIndices.has(wordIdx2)) {
                    [words[wordIdx1], words[wordIdx2]] = [words[wordIdx2], words[wordIdx1]];
                    swappedIndices.add(wordIdx1);
                    swappedIndices.add(wordIdx2);
                    swapsPerformed++;
                }
            }
            
            // Report progress
            if (progressCallback) {
                const progress = Math.min(1, swapsPerformed / swapsNeeded);
                progressCallback(progress);
            }
            
            // Check if we're done
            if (swapsPerformed >= swapsNeeded || longWordIndices.length < 2) {
                completeCallback(words.join(' '));
            } else {
                // Schedule the next chunk
                setTimeout(processChunk, 0);
            }
        }
        
        // Start processing
        setTimeout(processChunk, 0);
    }

    // Improved phoneme swap with chunking
    function enhancedPhonemeSwap(text, intensity, progressCallback, completeCallback) {
        console.log("Swapping phonemes with intensity:", intensity);
        
        const vowels = 'aeiouAEIOU';
        const vowelMap = {
            'a': ['e', 'o'],
            'e': ['i', 'a'],
            'i': ['e', 'y'],
            'o': ['a', 'u'],
            'u': ['o', 'oo'],
            'A': ['E', 'O'],
            'E': ['I', 'A'],
            'I': ['E', 'Y'],
            'O': ['A', 'U'],
            'U': ['O', 'OO']
        };

        const words = text.split(/\s+/);
        const wordsToTransform = getIntensityValue(words.length, intensity);
        const transformedIndices = new Set();
        let transformCount = 0;
        let currentIndex = 0;
        
        function processChunk() {
            const startTime = performance.now();
            
            // Process this chunk
            while (transformCount < wordsToTransform && 
                   currentIndex < words.length &&
                   performance.now() - startTime < 50) {
                   
                const randomIndex = Math.floor(Math.random() * words.length);
                if (words[randomIndex].length < 4 || transformedIndices.has(randomIndex)) {
                    currentIndex++;
                    continue;
                }

                let word = words[randomIndex];
                let transformed = '';
                let vowelFound = false;

                for (let i = 0; i < word.length; i++) {
                    const char = word[i];
                    if (vowels.includes(char)) {
                        const options = vowelMap[char] || [char];
                        transformed += options[Math.floor(Math.random() * options.length)];
                        vowelFound = true;
                    } else {
                        transformed += char;
                    }
                }

                if (vowelFound) {
                    words[randomIndex] = transformed;
                    transformedIndices.add(randomIndex);
                    transformCount++;
                }
                
                currentIndex++;
            }
            
            // Report progress
            if (progressCallback) {
                const progress = Math.min(1, transformCount / wordsToTransform);
                progressCallback(progress);
            }
            
            // Check if we're done
            if (transformCount >= wordsToTransform || currentIndex >= words.length) {
                completeCallback(words.join(' '));
            } else {
                // Schedule the next chunk
                setTimeout(processChunk, 0);
            }
        }
        
        // Start processing
        setTimeout(processChunk, 0);
    }

    // Improved consonant swap with chunking
    function consonantSwap(text, intensity, progressCallback, completeCallback) {
        console.log("Swapping consonants with intensity:", intensity);
        
        // Consonant pairs that won't lead to unreadable text
        const consonantPairs = {
            'b': 'p', 'p': 'b',
            'd': 't', 't': 'd',
            'g': 'k', 'k': 'g',
            'v': 'f', 'f': 'v',
            'z': 's', 's': 'z',
            'j': 'ch', 'c': 'k',
            'B': 'P', 'P': 'B',
            'D': 'T', 'T': 'D',
            'G': 'K', 'K': 'G',
            'V': 'F', 'F': 'V',
            'Z': 'S', 'S': 'Z',
            'J': 'Ch', 'C': 'K'
        };

        const words = text.split(/\s+/);
        const intensityValue = parseFloat(intensity === 'little' ? 0.1 :
            intensity === 'some' ? 0.2 :
                intensity === 'many' ? 0.4 :
                    0.6);
                    
        let processedCount = 0;
        const totalWords = words.length;
        const results = new Array(totalWords);
        
        // Use chunk processing to avoid UI freezing
        function processChunk(startIdx, endIdx) {
            const start = performance.now();
            
            for (let i = startIdx; i < endIdx && i < totalWords; i++) {
                const word = words[i];
                
                if (word.length < 4 || Math.random() > intensityValue) {
                    results[i] = word;
                    continue;
                }
                
                let result = '';
                for (let j = 0; j < word.length; j++) {
                    const char = word[j];
                    // Only swap some consonants to avoid making text unreadable
                    if (consonantPairs[char] && Math.random() < 0.5) {
                        result += consonantPairs[char];
                    } else {
                        result += char;
                    }
                }
                results[i] = result;
                
                // Check if we've been processing too long
                if (i % 10 === 0 && performance.now() - start > 50) {
                    processedCount = i + 1;
                    
                    // Report progress
                    if (progressCallback) {
                        progressCallback(processedCount / totalWords);
                    }
                    
                    // Schedule next chunk
                    setTimeout(() => processChunk(i + 1, endIdx), 0);
                    return;
                }
            }
            
            processedCount = endIdx;
            
            // Report progress
            if (progressCallback) {
                progressCallback(processedCount / totalWords);
            }
            
            if (processedCount >= totalWords) {
                completeCallback(results.join(' '));
            } else {
                // Process next chunk
                const nextEnd = Math.min(processedCount + 200, totalWords);
                setTimeout(() => processChunk(processedCount, nextEnd), 0);
            }
        }
        
        // Start processing in chunks of 200 words
        const firstChunkEnd = Math.min(200, totalWords);
        setTimeout(() => processChunk(0, firstChunkEnd), 0);
    }

    // Improved syllable inversion with chunking
    function invertSyllables(text, intensity, progressCallback, completeCallback) {
        console.log("Inverting syllables with intensity:", intensity);
        
        const words = text.split(/\s+/);
        const intensityValue = parseFloat(intensity === 'little' ? 0.1 :
            intensity === 'some' ? 0.25 :
                intensity === 'many' ? 0.5 :
                    0.75);
                    
        const totalWords = words.length;
        const results = new Array(totalWords);
        let processedCount = 0;
        
        function processChunk(startIdx, endIdx) {
            const start = performance.now();
            
            for (let i = startIdx; i < endIdx && i < totalWords; i++) {
                const word = words[i];
                
                if (word.length < 4 || Math.random() > intensityValue) {
                    results[i] = word;
                    continue;
                }
                
                // Simple approximation - reverse the word or swap halves
                if (Math.random() < 0.5) {
                    results[i] = word.split('').reverse().join('');
                } else {
                    const mid = Math.floor(word.length / 2);
                    results[i] = word.substring(mid) + word.substring(0, mid);
                }
                
                // Check if we've been processing too long
                if (i % 20 === 0 && performance.now() - start > 50) {
                    processedCount = i + 1;
                    
                    // Report progress
                    if (progressCallback) {
                        progressCallback(processedCount / totalWords);
                    }
                    
                    // Schedule next chunk
                    setTimeout(() => processChunk(i + 1, endIdx), 0);
                    return;
                }
            }
            
            processedCount = endIdx;
            
            // Report progress
            if (progressCallback) {
                progressCallback(processedCount / totalWords);
            }
            
            if (processedCount >= totalWords) {
                completeCallback(results.join(' '));
            } else {
                // Process next chunk
                const nextEnd = Math.min(processedCount + 200, totalWords);
                setTimeout(() => processChunk(processedCount, nextEnd), 0);
            }
        }
        
        // Start processing in chunks
        const firstChunkEnd = Math.min(200, totalWords);
        setTimeout(() => processChunk(0, firstChunkEnd), 0);
    }

    // Fixed caesura inversion with chunking
    function invertAtCaesura(text, intensity, progressCallback, completeCallback) {
        console.log("Inverting caesura with intensity:", intensity);
        
        // FIX: Split by newlines and preserve them in the result
        const lines = text.split('\n');
        const linesToTransform = getIntensityValue(lines.length, intensity);
        const transformedIndices = new Set();
        let transformCount = 0;
        let currentLineIndex = 0;
        const transformedLines = [...lines];
        
        function processChunk() {
            const startTime = performance.now();
            
            // Process lines in chunks
            while (transformCount < linesToTransform && 
                   currentLineIndex < lines.length &&
                   performance.now() - startTime < 50) {
                
                const randomIndex = Math.floor(Math.random() * lines.length);
                if (transformedIndices.has(randomIndex) || lines[randomIndex].trim().length < 10) {
                    currentLineIndex++;
                    continue;
                }

                const line = lines[randomIndex];
                // Find a natural division point
                let caesuraIndex = Math.floor(line.length / 2);

                // Check for punctuation first
                const punctuationMatch = line.match(/[;—,.]\s/);
                if (punctuationMatch) {
                    caesuraIndex = punctuationMatch.index + 1;
                } else {
                    // Or find nearest space to middle
                    const middleIndex = Math.floor(line.length / 2);
                    const beforeMiddle = line.lastIndexOf(' ', middleIndex);
                    const afterMiddle = line.indexOf(' ', middleIndex);

                    if (beforeMiddle !== -1 && afterMiddle !== -1) {
                        caesuraIndex = (middleIndex - beforeMiddle < afterMiddle - middleIndex) ?
                            beforeMiddle : afterMiddle;
                    } else if (beforeMiddle !== -1) {
                        caesuraIndex = beforeMiddle;
                    } else if (afterMiddle !== -1) {
                        caesuraIndex = afterMiddle;
                    } else {
                        caesuraIndex = middleIndex;
                    }
                }

                if (caesuraIndex > 0 && caesuraIndex < line.length - 1) {
                    const firstHalf = line.substring(0, caesuraIndex).trim();
                    const secondHalf = line.substring(caesuraIndex).trim();

                    transformedLines[randomIndex] = secondHalf + ' | ' + firstHalf;
                    transformedIndices.add(randomIndex);
                    transformCount++;
                }
                
                currentLineIndex++;
            }
            
            // Report progress
            if (progressCallback) {
                const progress = Math.min(1, transformCount / linesToTransform);
                progressCallback(progress);
            }
            
            // Check if we're done
            if (transformCount >= linesToTransform || currentLineIndex >= lines.length) {
                completeCallback(transformedLines.join('\n'));
            } else {
                // Schedule the next chunk
                setTimeout(processChunk, 0);
            }
        }
        
        // Start processing
        setTimeout(processChunk, 0);
    }

    // Fixed line reordering with chunking
    function reorderPoemLines(text, intensity, progressCallback, completeCallback) {
    console.log("Reordering poem lines with intensity:", intensity);
    
    // Split by newlines but preserve them
    const lines = text.split('\n');
    const nonEmptyLineIndices = [];
    
    // Find non-empty lines
    for (let i = 0; i < lines.length; i++) {
        if (lines[i].trim() !== '') {
            nonEmptyLineIndices.push(i);
        }
    }
    
    // Copy original lines
    const transformedLines = [...lines];
    
    // Determine how many pairs of lines to swap based on intensity
    const linesToReorder = Math.min(
        getIntensityValue(Math.floor(nonEmptyLineIndices.length / 2), intensity),
        Math.floor(nonEmptyLineIndices.length / 2)
    );
    
    // Track which indices we've already used
    const transformedIndices = new Set();
    let transformCount = 0;
    
    function processChunk() {
        const startTime = performance.now();
        
        // Process a chunk of swaps
        while (transformCount < linesToReorder && 
              nonEmptyLineIndices.length >= 2 &&
              performance.now() - startTime < 50) {
              
            // Get available indices (ones we haven't used yet)
            const availableIndices = nonEmptyLineIndices.filter(idx => !transformedIndices.has(idx));
            
            // If we don't have at least 2 available indices, break out
            if (availableIndices.length < 2) break;
            
            // Pick two random indices from available lines
            const randomIndex1 = Math.floor(Math.random() * availableIndices.length);
            let randomIndex2 = Math.floor(Math.random() * availableIndices.length);
            
            // Make sure we pick different indices
            while (randomIndex1 === randomIndex2) {
                randomIndex2 = Math.floor(Math.random() * availableIndices.length);
            }
            
            // Get the actual line indices from the original array
            const lineIdx1 = availableIndices[randomIndex1];
            const lineIdx2 = availableIndices[randomIndex2];
            
            // Swap lines
            [transformedLines[lineIdx1], transformedLines[lineIdx2]] = 
            [transformedLines[lineIdx2], transformedLines[lineIdx1]];
            
            // Mark these indices as used
            transformedIndices.add(lineIdx1);
            transformedIndices.add(lineIdx2);
            transformCount++;
        }
        
        // Report progress
        if (progressCallback) {
            const progress = Math.min(1, transformCount / linesToReorder);
            progressCallback(progress);
        }
        
        // Check if we're done
        if (transformCount >= linesToReorder || nonEmptyLineIndices.length < 2) {
            completeCallback(transformedLines.join('\n'));
        } else {
            // Schedule the next chunk
            setTimeout(processChunk, 0);
        }
    }
    
    // Start processing
    setTimeout(processChunk, 0);
}
    // Improved prefix freak with chunking
    function prefixFreak(text, intensity, progressCallback, completeCallback) {
        console.log("Prefix Freaking with intensity:", intensity);
        
        const prefixes = [
            "un", "in", "im", "il", "ir", "dis", "mono", "bi", "tri", "quad", "quart",
            "poly", "pre", "post", "re", "inter", "sub", "super", "sur", "hyper", "micro",
            "semi", "anti", "auto", "co", "ex", "mis", "non", "over", "pro", "trans",
            "under", "uni"
        ];
        
        const words = text.split(/\s+/);
        const freakAmount = getIntensityValue(words.length, intensity);
        let freakCount = 0;
        let processedWords = 0;
        const freaked = [...words];
        const usedIndexes = new Set();
        
        function processChunk() {
            const startTime = performance.now();
            
            while (freakCount < freakAmount && 
                   processedWords < words.length &&
                   performance.now() - startTime < 50) {
                   
                const randomIndex = Math.floor(Math.random() * words.length);
                if (usedIndexes.has(randomIndex) || words[randomIndex].length < 4) {
                    processedWords++;
                    continue;
                }
                
                const word = words[randomIndex].toLowerCase();
                let matched = false;
                
                // Try each prefix
                for (let i = 0; i < prefixes.length; i++) {
                    const prefix = prefixes[i];
                    if (word.startsWith(prefix) && word.length > prefix.length + 2) {
                        // Split the word and insert "freaking"
                        freaked[randomIndex] = word.substring(0, prefix.length) + 
                                              "-freaking-" + 
                                              word.substring(prefix.length);
                        
                        // Restore original case
                        if (words[randomIndex] !== word) {
                            // If first letter was uppercase, capitalize the result
                            if (words[randomIndex][0] === words[randomIndex][0].toUpperCase()) {
                                freaked[randomIndex] = freaked[randomIndex][0].toUpperCase() + 
                                                      freaked[randomIndex].substring(1);
                            }
                        }
                        
                        freakCount++;
                        usedIndexes.add(randomIndex);
                        matched = true;
                        break;
                    }
                }
                
                processedWords++;
            }
            
            // Report progress
            if (progressCallback) {
                const progress = Math.min(1, freakCount / freakAmount);
                progressCallback(progress);
            }
            
            // Check if we're done
            if (freakCount >= freakAmount || processedWords >= words.length) {
                completeCallback(freaked.join(' '));
            } else {
                // Schedule the next chunk
                setTimeout(processChunk, 0);
            }
        }
        
        // Start processing
        setTimeout(processChunk, 0);
    }

    // Simple lists for the two main conjunction categories
    const coordinatingConjunctions = new Set(["and", "but", "or", "nor", "for", "yet", "so"]);
    const subordinatingConjunctions = new Set([
        "although", "because", "if", "since", "though", "unless", "until", 
        "when", "where", "while", "after", "before", "as", "whereas", "whether"
    ]);

    // Helper function to shuffle array
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    // Fixed conjunction swap with chunking
    function simpleConjunctionSwap(text, intensity, progressCallback, completeCallback) {
        console.log("Swapping conjunctions with intensity:", intensity);
        
        // Convert to arrays for random selection
        const coordArray = Array.from(coordinatingConjunctions);
        const subordArray = Array.from(subordinatingConjunctions);
        
        const words = text.split(/\s+/);
        const result = [...words]; // Make a copy for the result
        
        // Find all conjunction indices first, then apply intensity to that subset
        const conjunctionIndices = [];
        for (let i = 0; i < words.length; i++) {
            // Strip punctuation for checking but keep it for later
            const cleanWord = words[i].toLowerCase().replace(/[.,;!?]+$/, '');
            if (coordinatingConjunctions.has(cleanWord) || subordinatingConjunctions.has(cleanWord)) {
                conjunctionIndices.push(i);
            }
        }
        
        // Shuffle the array of indices to ensure randomness across the text
        shuffleArray(conjunctionIndices);
        
        // Determine how many conjunctions to replace based on intensity
        const intensityValue = intensity === 'little' ? 0.25 :
                               intensity === 'some' ? 0.5 :
                               intensity === 'many' ? 0.75 : 0.9;
        
        const wordsToChange = Math.max(1, Math.floor(conjunctionIndices.length * intensityValue));
        
        // Limit to available conjunctions
        const indexesToProcess = conjunctionIndices.slice(0, wordsToChange);
        
        let changeCount = 0;
        let processedCount = 0;
        
        function processChunk() {
            const startTime = performance.now();
            
            // Process a chunk
            while (processedCount < indexesToProcess.length &&
                   performance.now() - startTime < 50) {
                   
                const currentIndex = indexesToProcess[processedCount];
                // Extract the original word and any trailing punctuation
                const originalWord = words[currentIndex];
                const punctMatch = originalWord.match(/([.,;!?]+)$/);
                const punctuation = punctMatch ? punctMatch[1] : '';
                const cleanWord = originalWord.toLowerCase().replace(/[.,;!?]+$/, '');
                
                // Determine which set the word belongs to
                let replacement = '';
                
                if (coordinatingConjunctions.has(cleanWord)) {
                    // Get other coordinating conjunctions
                    const options = coordArray.filter(conj => conj !== cleanWord);
                    replacement = options[Math.floor(Math.random() * options.length)];
                } else if (subordinatingConjunctions.has(cleanWord)) {
                    // Get other subordinating conjunctions
                    const options = subordArray.filter(conj => conj !== cleanWord);
                    replacement = options[Math.floor(Math.random() * options.length)];
                }
                
                if (replacement) {
                    // Preserve case
                    if (originalWord[0] === originalWord[0].toUpperCase()) {
                        replacement = replacement[0].toUpperCase() + replacement.slice(1);
                    }
                    
                    // Add back any punctuation
                    result[currentIndex] = replacement + punctuation;
                    changeCount++;
                }
                
                processedCount++;
            }
            
            // Report progress
            if (progressCallback) {
                const progress = Math.min(1, processedCount / indexesToProcess.length);
                progressCallback(progress);
            }
            
            // Check if we're done
            if (processedCount >= indexesToProcess.length) {
                completeCallback(result.join(' '));
            } else {
                // Schedule the next chunk
                setTimeout(processChunk, 0);
            }
        }
        
        // Start processing
        setTimeout(processChunk, 0);
    }

    // Main typing function
    async function typeText(text) {
        if (!paper) return;
        
        const chars = text.split('');
        let index = 0;
        const typingSpeed = 50; // ms between characters
        
        return new Promise((resolve) => {
            function typeNextChar() {
                if (stopTyping) {
                    resolve();
                    return;
                }
                
                if (index < chars.length) {
                    const char = chars[index++];
                    
                    // Animate the corresponding key
                    if (keyboard) {
                        let keyToAnimate;
                        
                        if (char === ' ') {
                            keyToAnimate = keyboard.querySelector('.key[data-char=" "]');
                        } else if (char === '\n') {
                            if (carriageReturn) {
                                carriageReturn.classList.add('active');
                                setTimeout(() => {
                                    carriageReturn.classList.remove('active');
                                }, 100);
                            }
                        } else {
                            keyToAnimate = keyboard.querySelector(`.key[data-char="${char.toLowerCase()}"]`);
                        }
                        
                        if (keyToAnimate) {
                            keyToAnimate.classList.add('active');
                            setTimeout(() => {
                                keyToAnimate.classList.remove('active');
                            }, 100);
                        }
                    }
                    
                    // Append to paper content
                    if (char === '\n') {
                        paperContent += '<br>';
                    } else {
                        paperContent += char;
                    }
                    
                    // Update paper
                    paper.innerHTML = paperContent;
                    paper.scrollTop = paper.scrollHeight;
                    
                    // Schedule next character
                    setTimeout(typeNextChar, typingSpeed);
                } else {
                    resolve();
                }
            }
            
            typeNextChar();
        });
    }

    // Function to simulate platen knob rotation
    function rotatePlatenKnobs() {
        if (!platenKnobs.length) return;
        
        platenKnobs.forEach(knob => {
            knob.style.transition = 'transform 0.3s';
            knob.style.transform = 'rotate(20deg)';
            
            setTimeout(() => {
                knob.style.transform = 'rotate(0deg)';
            }, 300);
        });
    }

    // Main function to handle typing start
    function startTyping() {
        if (typingInProgress || !textInput || !paper) return;
        
        const text = textInput.value.trim();
        if (!text) {
            displayError("Please enter some text first!");
            return;
        }
        
        typingInProgress = true;
        stopTyping = false;
        
        // Disable buttons during typing
        if (startTypingBtn) startTypingBtn.disabled = true;
        if (stopTypingBtn) stopTypingBtn.disabled = false;
        
        // Start typing animation
        typeText(text).then(() => {
            typingInProgress = false;
            if (startTypingBtn) startTypingBtn.disabled = false;
            if (stopTypingBtn) stopTypingBtn.disabled = true;
        });
    }

    // Function to stop typing
    function stopTypingText() {
        stopTyping = true;
        if (stopTypingBtn) stopTypingBtn.disabled = true;
        if (startTypingBtn) startTypingBtn.disabled = false;
    }

    // Clear paper content
    function clearPaper() {
        if (paper) {
            paperContent = '';
            paper.innerHTML = paperContent;
        }
    }

    // Helper function to create a shared worker structure for all text transformations
    function transformText(transformFunction) {
        if (processingTask) {
            displayError("A transformation is already in progress. Please wait.");
            return;
        }
        
        if (!textInput) {
            console.error("Text input not found");
            return;
        }
        
        const text = textInput.value.trim();
        if (!text) {
            displayError("Please enter some text first!");
            return;
        }
        
        const intensity = transformIntensity ? transformIntensity.value : 'some';
        setProcessingStatus(true);
        
        // Store the current transformation for potential cancellation
        processingTask = { cancelled: false };
        const currentTask = processingTask;
        
        // Start the transformation in a chunked way
        transformFunction(text, intensity, 
            (progress) => {
                // Progress callback - update UI if needed
                if (currentTask.cancelled) {
                    setProcessingStatus(false);
                    return;
                }
            },
            (result) => {
                // Complete callback
                if (!currentTask.cancelled) {
                    updateText(result);
                    setProcessingStatus(false);
                    processingTask = null;
                    rotatePlatenKnobs();
                }
            }
        );
    }

    // Download text as TXT file
    function downloadText() {
        const text = paper.innerText || '';
        if (!text) {
            displayError("No text to download!");
            return;
        }
        
        const blob = new Blob([text], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'typewriter-text.txt';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    // Event listeners
    if (startTypingBtn) {
        startTypingBtn.addEventListener('click', startTyping);
    }
    
    if (stopTypingBtn) {
        stopTypingBtn.addEventListener('click', stopTypingText);
    }
    
    if (clearPaperBtn) {
        clearPaperBtn.addEventListener('click', clearPaper);
    }
    
    if (downloadBtn) {
        downloadBtn.addEventListener('click', downloadText);
    }
    
    // Text transformation buttons
    if (madlibBtn) {
        madlibBtn.addEventListener('click', () => transformText(createMadlib));
    }
    
    if (wordswapBtn) {
        wordswapBtn.addEventListener('click', () => transformText(shuffleLongWords));
    }
    
    if (phonemeSwapBtn) {
        phonemeSwapBtn.addEventListener('click', () => transformText(enhancedPhonemeSwap));
    }
    
    if (consonantSwapBtn) {
        consonantSwapBtn.addEventListener('click', () => transformText(consonantSwap));
    }
    
    if (syllableInversionBtn) {
        syllableInversionBtn.addEventListener('click', () => transformText(invertSyllables));
    }
    
    if (caesuraInversionBtn) {
        caesuraInversionBtn.addEventListener('click', () => transformText(invertAtCaesura));
    }
    
    if (lineSwapBtn) {
        lineSwapBtn.addEventListener('click', () => transformText(reorderPoemLines));
    }
    
    if (prefixFreakBtn) {
        prefixFreakBtn.addEventListener('click', () => transformText(prefixFreak));
    }
    
    if (conjunctionSwapBtn) {
        conjunctionSwapBtn.addEventListener('click', () => transformText(simpleConjunctionSwap));
    }

    console.log("Typewriter initialized successfully");
}
</script>
